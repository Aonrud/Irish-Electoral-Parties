(function (factory) {
  typeof define === 'function' && define.amd ? define(factory) :
  factory();
})((function () { 'use strict';

  var z={header:!0,newlineChar:"",delimiterChar:"",quoteChar:'"',detectCharLength:1024,emptyFieldValue:"",coerceField:e=>e,commentPrefixValue:!1,errorOnComment:!0,errorOnEmptyLine:!0,errorOnExtraFields:!0,errorOnMissingFields:!0},L=e=>e.length,re=e=>e.replace(/[\\^$*+?.()|[\]{}]/g,"\\$&"),ne=(e={})=>{let t={...z,...e};t.escapeChar??=t.quoteChar;let{header:o,newlineChar:r,delimiterChar:h}=t,{detectCharLength:s,quoteChar:l,escapeChar:g,commentPrefixValue:k,emptyFieldValue:F,coerceField:C,errorOnEmptyLine:Q,errorOnComment:x,errorOnExtraFields:J,errorOnMissingFields:U}=t,m=L(o),A=/,|\t|\||;|\x1E|\x1F/g,B=/\r\n|\n|\r/g,G=g+l,H=new RegExp(`${re(G)}`,"g"),K=g===l,W=g!==l,O=L(r),X=1,P=1,Y=1,Z=2,i,q,u,b,S,f="",w=0,_=a=>{if(w+=1,o===!0){o=a,m=L(o);return}let c=a;if(m){let p=L(a);if(U&&p<m){N("MissingFields",`Too few fields were parsed, expected ${m}.`);return}else if(m<p){if(J){N("ExtraFields",`Too many fields were parsed, expected ${m}.`);return}p=m;}c={};for(let d=0;d<p;d++)c[o[d]]=a[d];}S({idx:w,data:c});},N=(a,c)=>{S({idx:w,err:{code:a,message:c}});},E=(a,c=u)=>i.indexOf(a,c),T=a=>i.substring(u,a),ee=(a,c)=>C(a||F,c),te=(a,c)=>{b.push(ee(a,c));},R=()=>{if(E(r)===u)return w+=1,u+=O,Q&&N("EmptyLineExists","Empty line detected."),R();if(k&&E(k)===u)return w+=1,u=E(r)+O,x&&N("CommentExists","Comment detected."),R()};return {chunkParse:(a,c,p=!1)=>{if(i=a,q=L(i),S=c.enqueue,f="",u=0,b=[],!r){if(r=I(i.substring(0,s),B),!r)if(i.length<s&&!p){f=i;return}else throw new Error("newlineCharUnknown");O=L(r);}h||=I(i.substring(0,s),A),R();let d=0;for(;;){let V,n=u,$,j;if(i[u]===l)for(u+=P,V=!0,n=u;;){if(n=E(l,n),n<0){if(f=i.substring(d,q)+f,p)throw new Error("QuotedFieldMalformed",{cause:w});return}if(K&&i[n+P]===l){n+=Z;continue}if(W&&i[n-Y]===g){n+=P;continue}break}let D=E(h,n),v=E(r,n);if(v<0){if(!p){f=i.substring(d,q)+f;return}v=q;}if(D>-1&&D<v?(n=D,$=X):(n=v,$=O,j=!0),n<0||!n)break;let M;if(V?M=T(n-1).replace(H,l):M=T(n),te(M,b.length),u=n+$,j&&(_(b),b=[],R(),d=u),q<=u&&b.length===0)break}},header:()=>o,previousChunk:()=>f}},I=(e,t)=>{let o,r={};for(;o=t.exec(e);){let s=o[0];if(r[s]??=0,r[s]+=1,r[s]>5)return s}let{key:h}=Object.keys(r).map(s=>({key:s,value:r[s]})).sort((s,l)=>s.value-l.value)?.[0]??{};if(!!h)return h},se=(e,t)=>{let o={...z,enableReturn:!0,chunkSize:67108864,enqueue:()=>{},...t},{chunkSize:r,enableReturn:h,enqueue:s}=o,{chunkParse:l,previousChunk:g}=ne(o),k=[],F={enqueue:s};h&&(F.enqueue=x=>{s(x),k.push(x.data);});let C=0;for(;C<e.length;){let x=g()+e.substring(C,C+r);l(x,F),C+=r;}let Q=g();return l(Q,F,!0),h&&k};

  const a=se;

  /**
  * Panzoom for panning and zooming elements using CSS transforms
  * Copyright Timmy Willison and other contributors
  * https://github.com/timmywil/panzoom/blob/main/MIT-License.txt
  */
  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };

  /* eslint-disable no-var */
  if (typeof window !== 'undefined') {
    // Support: IE11 only
    if (window.NodeList && !NodeList.prototype.forEach) {
      NodeList.prototype.forEach = Array.prototype.forEach;
    }
    // Support: IE11 only
    // CustomEvent is an object instead of a constructor
    if (typeof window.CustomEvent !== 'function') {
      window.CustomEvent = function CustomEvent(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: null };
        var evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt
      };
    }
  }

  /**
   * Utilites for working with multiple pointer events
   */
  function findEventIndex(pointers, event) {
      var i = pointers.length;
      while (i--) {
          if (pointers[i].pointerId === event.pointerId) {
              return i;
          }
      }
      return -1;
  }
  function addPointer(pointers, event) {
      var i;
      // Add touches if applicable
      if (event.touches) {
          i = 0;
          for (var _i = 0, _a = event.touches; _i < _a.length; _i++) {
              var touch = _a[_i];
              touch.pointerId = i++;
              addPointer(pointers, touch);
          }
          return;
      }
      i = findEventIndex(pointers, event);
      // Update if already present
      if (i > -1) {
          pointers.splice(i, 1);
      }
      pointers.push(event);
  }
  function removePointer(pointers, event) {
      // Add touches if applicable
      if (event.touches) {
          // Remove all touches
          while (pointers.length) {
              pointers.pop();
          }
          return;
      }
      var i = findEventIndex(pointers, event);
      if (i > -1) {
          pointers.splice(i, 1);
      }
  }
  /**
   * Calculates a center point between
   * the given pointer events, for panning
   * with multiple pointers.
   */
  function getMiddle(pointers) {
      // Copy to avoid changing by reference
      pointers = pointers.slice(0);
      var event1 = pointers.pop();
      var event2;
      while ((event2 = pointers.pop())) {
          event1 = {
              clientX: (event2.clientX - event1.clientX) / 2 + event1.clientX,
              clientY: (event2.clientY - event1.clientY) / 2 + event1.clientY
          };
      }
      return event1;
  }
  /**
   * Calculates the distance between two points
   * for pinch zooming.
   * Limits to the first 2
   */
  function getDistance(pointers) {
      if (pointers.length < 2) {
          return 0;
      }
      var event1 = pointers[0];
      var event2 = pointers[1];
      return Math.sqrt(Math.pow(Math.abs(event2.clientX - event1.clientX), 2) +
          Math.pow(Math.abs(event2.clientY - event1.clientY), 2));
  }

  var events = {
      down: 'mousedown',
      move: 'mousemove',
      up: 'mouseup mouseleave'
  };
  if (typeof window !== 'undefined') {
      if (typeof window.PointerEvent === 'function') {
          events = {
              down: 'pointerdown',
              move: 'pointermove',
              up: 'pointerup pointerleave pointercancel'
          };
      }
      else if (typeof window.TouchEvent === 'function') {
          events = {
              down: 'touchstart',
              move: 'touchmove',
              up: 'touchend touchcancel'
          };
      }
  }
  function onPointer(event, elem, handler, eventOpts) {
      events[event].split(' ').forEach(function (name) {
          elem.addEventListener(name, handler, eventOpts);
      });
  }
  function destroyPointer(event, elem, handler) {
      events[event].split(' ').forEach(function (name) {
          elem.removeEventListener(name, handler);
      });
  }

  var isIE = typeof document !== 'undefined' && !!document.documentMode;
  /**
   * Lazy creation of a CSS style declaration
   */
  var divStyle;
  function createStyle() {
      if (divStyle) {
          return divStyle;
      }
      return (divStyle = document.createElement('div').style);
  }
  /**
   * Proper prefixing for cross-browser compatibility
   */
  var prefixes = ['webkit', 'moz', 'ms'];
  var prefixCache = {};
  function getPrefixedName(name) {
      if (prefixCache[name]) {
          return prefixCache[name];
      }
      var divStyle = createStyle();
      if (name in divStyle) {
          return (prefixCache[name] = name);
      }
      var capName = name[0].toUpperCase() + name.slice(1);
      var i = prefixes.length;
      while (i--) {
          var prefixedName = "".concat(prefixes[i]).concat(capName);
          if (prefixedName in divStyle) {
              return (prefixCache[name] = prefixedName);
          }
      }
  }
  /**
   * Gets a style value expected to be a number
   */
  function getCSSNum(name, style) {
      return parseFloat(style[getPrefixedName(name)]) || 0;
  }
  function getBoxStyle(elem, name, style) {
      if (style === void 0) { style = window.getComputedStyle(elem); }
      // Support: FF 68+
      // Firefox requires specificity for border
      var suffix = name === 'border' ? 'Width' : '';
      return {
          left: getCSSNum("".concat(name, "Left").concat(suffix), style),
          right: getCSSNum("".concat(name, "Right").concat(suffix), style),
          top: getCSSNum("".concat(name, "Top").concat(suffix), style),
          bottom: getCSSNum("".concat(name, "Bottom").concat(suffix), style)
      };
  }
  /**
   * Set a style using the properly prefixed name
   */
  function setStyle(elem, name, value) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      elem.style[getPrefixedName(name)] = value;
  }
  /**
   * Constructs the transition from panzoom options
   * and takes care of prefixing the transition and transform
   */
  function setTransition(elem, options) {
      var transform = getPrefixedName('transform');
      setStyle(elem, 'transition', "".concat(transform, " ").concat(options.duration, "ms ").concat(options.easing));
  }
  /**
   * Set the transform using the proper prefix
   *
   * Override the transform setter.
   * This is exposed mostly so the user could
   * set other parts of a transform
   * aside from scale and translate.
   * Default is defined in src/css.ts.
   *
   * ```js
   * // This example always sets a rotation
   * // when setting the scale and translation
   * const panzoom = Panzoom(elem, {
   *   setTransform: (elem, { scale, x, y }) => {
   *     panzoom.setStyle('transform', `rotate(0.5turn) scale(${scale}) translate(${x}px, ${y}px)`)
   *   }
   * })
   * ```
   */
  function setTransform(elem, _a, _options) {
      var x = _a.x, y = _a.y, scale = _a.scale, isSVG = _a.isSVG;
      setStyle(elem, 'transform', "scale(".concat(scale, ") translate(").concat(x, "px, ").concat(y, "px)"));
      if (isSVG && isIE) {
          var matrixValue = window.getComputedStyle(elem).getPropertyValue('transform');
          elem.setAttribute('transform', matrixValue);
      }
  }
  /**
   * Dimensions used in containment and focal point zooming
   */
  function getDimensions(elem) {
      var parent = elem.parentNode;
      var style = window.getComputedStyle(elem);
      var parentStyle = window.getComputedStyle(parent);
      var rectElem = elem.getBoundingClientRect();
      var rectParent = parent.getBoundingClientRect();
      return {
          elem: {
              style: style,
              width: rectElem.width,
              height: rectElem.height,
              top: rectElem.top,
              bottom: rectElem.bottom,
              left: rectElem.left,
              right: rectElem.right,
              margin: getBoxStyle(elem, 'margin', style),
              border: getBoxStyle(elem, 'border', style)
          },
          parent: {
              style: parentStyle,
              width: rectParent.width,
              height: rectParent.height,
              top: rectParent.top,
              bottom: rectParent.bottom,
              left: rectParent.left,
              right: rectParent.right,
              padding: getBoxStyle(parent, 'padding', parentStyle),
              border: getBoxStyle(parent, 'border', parentStyle)
          }
      };
  }

  /**
   * Determine if an element is attached to the DOM
   * Panzoom requires this so events work properly
   */
  function isAttached(elem) {
      var doc = elem.ownerDocument;
      var parent = elem.parentNode;
      return (doc &&
          parent &&
          doc.nodeType === 9 &&
          parent.nodeType === 1 &&
          doc.documentElement.contains(parent));
  }

  function getClass(elem) {
      return (elem.getAttribute('class') || '').trim();
  }
  function hasClass(elem, className) {
      return elem.nodeType === 1 && " ".concat(getClass(elem), " ").indexOf(" ".concat(className, " ")) > -1;
  }
  function isExcluded(elem, options) {
      for (var cur = elem; cur != null; cur = cur.parentNode) {
          if (hasClass(cur, options.excludeClass) || options.exclude.indexOf(cur) > -1) {
              return true;
          }
      }
      return false;
  }

  /**
   * Determine if an element is SVG by checking the namespace
   * Exception: the <svg> element itself should be treated like HTML
   */
  var rsvg = /^http:[\w\.\/]+svg$/;
  function isSVGElement(elem) {
      return rsvg.test(elem.namespaceURI) && elem.nodeName.toLowerCase() !== 'svg';
  }

  function shallowClone(obj) {
      var clone = {};
      for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
              clone[key] = obj[key];
          }
      }
      return clone;
  }

  var defaultOptions = {
      animate: false,
      canvas: false,
      cursor: 'move',
      disablePan: false,
      disableZoom: false,
      disableXAxis: false,
      disableYAxis: false,
      duration: 200,
      easing: 'ease-in-out',
      exclude: [],
      excludeClass: 'panzoom-exclude',
      handleStartEvent: function (e) {
          e.preventDefault();
          e.stopPropagation();
      },
      maxScale: 4,
      minScale: 0.125,
      overflow: 'hidden',
      panOnlyWhenZoomed: false,
      pinchAndPan: false,
      relative: false,
      setTransform: setTransform,
      startX: 0,
      startY: 0,
      startScale: 1,
      step: 0.3,
      touchAction: 'none'
  };
  function Panzoom(elem, options) {
      if (!elem) {
          throw new Error('Panzoom requires an element as an argument');
      }
      if (elem.nodeType !== 1) {
          throw new Error('Panzoom requires an element with a nodeType of 1');
      }
      if (!isAttached(elem)) {
          throw new Error('Panzoom should be called on elements that have been attached to the DOM');
      }
      options = __assign(__assign({}, defaultOptions), options);
      var isSVG = isSVGElement(elem);
      var parent = elem.parentNode;
      // Set parent styles
      parent.style.overflow = options.overflow;
      parent.style.userSelect = 'none';
      // This is important for mobile to
      // prevent scrolling while panning
      parent.style.touchAction = options.touchAction;
      (options.canvas ? parent : elem).style.cursor = options.cursor;
      // Set element styles
      elem.style.userSelect = 'none';
      elem.style.touchAction = options.touchAction;
      // The default for HTML is '50% 50%'
      // The default for SVG is '0 0'
      // SVG can't be changed in IE
      setStyle(elem, 'transformOrigin', typeof options.origin === 'string' ? options.origin : isSVG ? '0 0' : '50% 50%');
      function resetStyle() {
          parent.style.overflow = '';
          parent.style.userSelect = '';
          parent.style.touchAction = '';
          parent.style.cursor = '';
          elem.style.cursor = '';
          elem.style.userSelect = '';
          elem.style.touchAction = '';
          setStyle(elem, 'transformOrigin', '');
      }
      function setOptions(opts) {
          if (opts === void 0) { opts = {}; }
          for (var key in opts) {
              if (opts.hasOwnProperty(key)) {
                  options[key] = opts[key];
              }
          }
          // Handle option side-effects
          if (opts.hasOwnProperty('cursor') || opts.hasOwnProperty('canvas')) {
              parent.style.cursor = elem.style.cursor = '';
              (options.canvas ? parent : elem).style.cursor = options.cursor;
          }
          if (opts.hasOwnProperty('overflow')) {
              parent.style.overflow = opts.overflow;
          }
          if (opts.hasOwnProperty('touchAction')) {
              parent.style.touchAction = opts.touchAction;
              elem.style.touchAction = opts.touchAction;
          }
      }
      var x = 0;
      var y = 0;
      var scale = 1;
      var isPanning = false;
      zoom(options.startScale, { animate: false, force: true });
      // Wait for scale to update
      // for accurate dimensions
      // to constrain initial values
      setTimeout(function () {
          pan(options.startX, options.startY, { animate: false, force: true });
      });
      function trigger(eventName, detail, opts) {
          if (opts.silent) {
              return;
          }
          var event = new CustomEvent(eventName, { detail: detail });
          elem.dispatchEvent(event);
      }
      function setTransformWithEvent(eventName, opts, originalEvent) {
          var value = { x: x, y: y, scale: scale, isSVG: isSVG, originalEvent: originalEvent };
          requestAnimationFrame(function () {
              if (typeof opts.animate === 'boolean') {
                  if (opts.animate) {
                      setTransition(elem, opts);
                  }
                  else {
                      setStyle(elem, 'transition', 'none');
                  }
              }
              opts.setTransform(elem, value, opts);
              trigger(eventName, value, opts);
              trigger('panzoomchange', value, opts);
          });
          return value;
      }
      function constrainXY(toX, toY, toScale, panOptions) {
          var opts = __assign(__assign({}, options), panOptions);
          var result = { x: x, y: y, opts: opts };
          if (!opts.force && (opts.disablePan || (opts.panOnlyWhenZoomed && scale === opts.startScale))) {
              return result;
          }
          toX = parseFloat(toX);
          toY = parseFloat(toY);
          if (!opts.disableXAxis) {
              result.x = (opts.relative ? x : 0) + toX;
          }
          if (!opts.disableYAxis) {
              result.y = (opts.relative ? y : 0) + toY;
          }
          if (opts.contain) {
              var dims = getDimensions(elem);
              var realWidth = dims.elem.width / scale;
              var realHeight = dims.elem.height / scale;
              var scaledWidth = realWidth * toScale;
              var scaledHeight = realHeight * toScale;
              var diffHorizontal = (scaledWidth - realWidth) / 2;
              var diffVertical = (scaledHeight - realHeight) / 2;
              if (opts.contain === 'inside') {
                  var minX = (-dims.elem.margin.left - dims.parent.padding.left + diffHorizontal) / toScale;
                  var maxX = (dims.parent.width -
                      scaledWidth -
                      dims.parent.padding.left -
                      dims.elem.margin.left -
                      dims.parent.border.left -
                      dims.parent.border.right +
                      diffHorizontal) /
                      toScale;
                  result.x = Math.max(Math.min(result.x, maxX), minX);
                  var minY = (-dims.elem.margin.top - dims.parent.padding.top + diffVertical) / toScale;
                  var maxY = (dims.parent.height -
                      scaledHeight -
                      dims.parent.padding.top -
                      dims.elem.margin.top -
                      dims.parent.border.top -
                      dims.parent.border.bottom +
                      diffVertical) /
                      toScale;
                  result.y = Math.max(Math.min(result.y, maxY), minY);
              }
              else if (opts.contain === 'outside') {
                  var minX = (-(scaledWidth - dims.parent.width) -
                      dims.parent.padding.left -
                      dims.parent.border.left -
                      dims.parent.border.right +
                      diffHorizontal) /
                      toScale;
                  var maxX = (diffHorizontal - dims.parent.padding.left) / toScale;
                  result.x = Math.max(Math.min(result.x, maxX), minX);
                  var minY = (-(scaledHeight - dims.parent.height) -
                      dims.parent.padding.top -
                      dims.parent.border.top -
                      dims.parent.border.bottom +
                      diffVertical) /
                      toScale;
                  var maxY = (diffVertical - dims.parent.padding.top) / toScale;
                  result.y = Math.max(Math.min(result.y, maxY), minY);
              }
          }
          if (opts.roundPixels) {
              result.x = Math.round(result.x);
              result.y = Math.round(result.y);
          }
          return result;
      }
      function constrainScale(toScale, zoomOptions) {
          var opts = __assign(__assign({}, options), zoomOptions);
          var result = { scale: scale, opts: opts };
          if (!opts.force && opts.disableZoom) {
              return result;
          }
          var minScale = options.minScale;
          var maxScale = options.maxScale;
          if (opts.contain) {
              var dims = getDimensions(elem);
              var elemWidth = dims.elem.width / scale;
              var elemHeight = dims.elem.height / scale;
              if (elemWidth > 1 && elemHeight > 1) {
                  var parentWidth = dims.parent.width - dims.parent.border.left - dims.parent.border.right;
                  var parentHeight = dims.parent.height - dims.parent.border.top - dims.parent.border.bottom;
                  var elemScaledWidth = parentWidth / elemWidth;
                  var elemScaledHeight = parentHeight / elemHeight;
                  if (options.contain === 'inside') {
                      maxScale = Math.min(maxScale, elemScaledWidth, elemScaledHeight);
                  }
                  else if (options.contain === 'outside') {
                      minScale = Math.max(minScale, elemScaledWidth, elemScaledHeight);
                  }
              }
          }
          result.scale = Math.min(Math.max(toScale, minScale), maxScale);
          return result;
      }
      function pan(toX, toY, panOptions, originalEvent) {
          var result = constrainXY(toX, toY, scale, panOptions);
          // Only try to set if the result is somehow different
          if (x !== result.x || y !== result.y) {
              x = result.x;
              y = result.y;
              return setTransformWithEvent('panzoompan', result.opts, originalEvent);
          }
          return { x: x, y: y, scale: scale, isSVG: isSVG, originalEvent: originalEvent };
      }
      function zoom(toScale, zoomOptions, originalEvent) {
          var result = constrainScale(toScale, zoomOptions);
          var opts = result.opts;
          if (!opts.force && opts.disableZoom) {
              return;
          }
          toScale = result.scale;
          var toX = x;
          var toY = y;
          if (opts.focal) {
              // The difference between the point after the scale and the point before the scale
              // plus the current translation after the scale
              // neutralized to no scale (as the transform scale will apply to the translation)
              var focal = opts.focal;
              toX = (focal.x / toScale - focal.x / scale + x * toScale) / toScale;
              toY = (focal.y / toScale - focal.y / scale + y * toScale) / toScale;
          }
          var panResult = constrainXY(toX, toY, toScale, { relative: false, force: true });
          x = panResult.x;
          y = panResult.y;
          scale = toScale;
          return setTransformWithEvent('panzoomzoom', opts, originalEvent);
      }
      function zoomInOut(isIn, zoomOptions) {
          var opts = __assign(__assign(__assign({}, options), { animate: true }), zoomOptions);
          return zoom(scale * Math.exp((isIn ? 1 : -1) * opts.step), opts);
      }
      function zoomIn(zoomOptions) {
          return zoomInOut(true, zoomOptions);
      }
      function zoomOut(zoomOptions) {
          return zoomInOut(false, zoomOptions);
      }
      function zoomToPoint(toScale, point, zoomOptions, originalEvent) {
          var dims = getDimensions(elem);
          // Instead of thinking of operating on the panzoom element,
          // think of operating on the area inside the panzoom
          // element's parent
          // Subtract padding and border
          var effectiveArea = {
              width: dims.parent.width -
                  dims.parent.padding.left -
                  dims.parent.padding.right -
                  dims.parent.border.left -
                  dims.parent.border.right,
              height: dims.parent.height -
                  dims.parent.padding.top -
                  dims.parent.padding.bottom -
                  dims.parent.border.top -
                  dims.parent.border.bottom
          };
          // Adjust the clientX/clientY to ignore the area
          // outside the effective area
          var clientX = point.clientX -
              dims.parent.left -
              dims.parent.padding.left -
              dims.parent.border.left -
              dims.elem.margin.left;
          var clientY = point.clientY -
              dims.parent.top -
              dims.parent.padding.top -
              dims.parent.border.top -
              dims.elem.margin.top;
          // Adjust the clientX/clientY for HTML elements,
          // because they have a transform-origin of 50% 50%
          if (!isSVG) {
              clientX -= dims.elem.width / scale / 2;
              clientY -= dims.elem.height / scale / 2;
          }
          // Convert the mouse point from it's position over the
          // effective area before the scale to the position
          // over the effective area after the scale.
          var focal = {
              x: (clientX / effectiveArea.width) * (effectiveArea.width * toScale),
              y: (clientY / effectiveArea.height) * (effectiveArea.height * toScale)
          };
          return zoom(toScale, __assign(__assign({}, zoomOptions), { animate: false, focal: focal }), originalEvent);
      }
      function zoomWithWheel(event, zoomOptions) {
          // Need to prevent the default here
          // or it conflicts with regular page scroll
          event.preventDefault();
          var opts = __assign(__assign(__assign({}, options), zoomOptions), { animate: false });
          // Normalize to deltaX in case shift modifier is used on Mac
          var delta = event.deltaY === 0 && event.deltaX ? event.deltaX : event.deltaY;
          var wheel = delta < 0 ? 1 : -1;
          var toScale = constrainScale(scale * Math.exp((wheel * opts.step) / 3), opts).scale;
          return zoomToPoint(toScale, event, opts, event);
      }
      function reset(resetOptions) {
          var opts = __assign(__assign(__assign({}, options), { animate: true, force: true }), resetOptions);
          scale = constrainScale(opts.startScale, opts).scale;
          var panResult = constrainXY(opts.startX, opts.startY, scale, opts);
          x = panResult.x;
          y = panResult.y;
          return setTransformWithEvent('panzoomreset', opts);
      }
      var origX;
      var origY;
      var startClientX;
      var startClientY;
      var startScale;
      var startDistance;
      var pointers = [];
      function handleDown(event) {
          // Don't handle this event if the target is excluded
          if (isExcluded(event.target, options)) {
              return;
          }
          addPointer(pointers, event);
          isPanning = true;
          options.handleStartEvent(event);
          origX = x;
          origY = y;
          trigger('panzoomstart', { x: x, y: y, scale: scale, isSVG: isSVG, originalEvent: event }, options);
          // This works whether there are multiple
          // pointers or not
          var point = getMiddle(pointers);
          startClientX = point.clientX;
          startClientY = point.clientY;
          startScale = scale;
          startDistance = getDistance(pointers);
      }
      function handleMove(event) {
          if (!isPanning ||
              origX === undefined ||
              origY === undefined ||
              startClientX === undefined ||
              startClientY === undefined) {
              return;
          }
          addPointer(pointers, event);
          var current = getMiddle(pointers);
          var hasMultiple = pointers.length > 1;
          var toScale = scale;
          if (hasMultiple) {
              // A startDistance of 0 means
              // that there weren't 2 pointers
              // handled on start
              if (startDistance === 0) {
                  startDistance = getDistance(pointers);
              }
              // Use the distance between the first 2 pointers
              // to determine the current scale
              var diff = getDistance(pointers) - startDistance;
              toScale = constrainScale((diff * options.step) / 80 + startScale).scale;
              zoomToPoint(toScale, current, { animate: false }, event);
          }
          // Pan during pinch if pinchAndPan is true.
          // Note: some calculations may be off because the zoom
          // above has not yet rendered. However, the behavior
          // was removed before the new scale was used in the following
          // pan calculation.
          // See https://github.com/timmywil/panzoom/issues/512
          // and https://github.com/timmywil/panzoom/issues/606
          if (!hasMultiple || options.pinchAndPan) {
              pan(origX + (current.clientX - startClientX) / toScale, origY + (current.clientY - startClientY) / toScale, {
                  animate: false
              }, event);
          }
      }
      function handleUp(event) {
          // Don't call panzoomend when panning with 2 touches
          // until both touches end
          if (pointers.length === 1) {
              trigger('panzoomend', { x: x, y: y, scale: scale, isSVG: isSVG, originalEvent: event }, options);
          }
          // Note: don't remove all pointers
          // Can restart without having to reinitiate all of them
          // Remove the pointer regardless of the isPanning state
          removePointer(pointers, event);
          if (!isPanning) {
              return;
          }
          isPanning = false;
          origX = origY = startClientX = startClientY = undefined;
      }
      var bound = false;
      function bind() {
          if (bound) {
              return;
          }
          bound = true;
          onPointer('down', options.canvas ? parent : elem, handleDown);
          onPointer('move', document, handleMove, { passive: true });
          onPointer('up', document, handleUp, { passive: true });
      }
      function destroy() {
          bound = false;
          destroyPointer('down', options.canvas ? parent : elem, handleDown);
          destroyPointer('move', document, handleMove);
          destroyPointer('up', document, handleUp);
      }
      if (!options.noBind) {
          bind();
      }
      return {
          bind: bind,
          destroy: destroy,
          eventNames: events,
          getPan: function () { return ({ x: x, y: y }); },
          getScale: function () { return scale; },
          getOptions: function () { return shallowClone(options); },
          handleDown: handleDown,
          handleMove: handleMove,
          handleUp: handleUp,
          pan: pan,
          reset: reset,
          resetStyle: resetStyle,
          setOptions: setOptions,
          setStyle: function (name, value) { return setStyle(elem, name, value); },
          zoom: zoom,
          zoomIn: zoomIn,
          zoomOut: zoomOut,
          zoomToPoint: zoomToPoint,
          zoomWithWheel: zoomWithWheel
      };
  }
  Panzoom.defaultOptions = defaultOptions;

  /*! Timeline
   *Copyright (C) 2021 Aonghus Storey
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  const svgns = "http://www.w3.org/2000/svg";

  /**
   * A class for drawing lines with SVG.
   */
  class SvgConnector {
  	
  	/**
  	 * Create an SVG element drawing a line between the specified start and end points, with optional markers at each end.
  	 * The SVG returned will be absolutely positioned and should be appended to the document as needed by the caller.
  	 *
  	 * @static
  	 * @param {object} settings
  	 * @param {object} settings.start - The x and y coordinates of the start point
  	 * @param {number} settings.start.x
  	 * @param {number} settings.start.y
  	 * @param {object} settings.end - The x and y coordinates of the end point
  	 * @param {number} settings.end.x
  	 * @param {number} settings.end.y
  	 * @param {string} settings.stroke - The stroke width in px of the line
  	 * @param {string} settings.colour - The colour of the line. Will be set on the SVG element and inherited, so can be e.g. a CSS var().
  	 * @param {array.<string>} [settings.markers] - An array of two string values indicating the start and end markers respectively.
  	 * 		Valid values are "circle", "square" and "dots" (the last can only be used for end).
  	 * @param {string} [settings.dashes] - A dasharray string for the SVG line. If omitted, a solid line will be used.
  	 * 		Must be a valid SVG dasharray (@see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray})
  	 * @param {String} [settings.title] - If included, a title element will be included on the line with the given text.
  	 * @return {object}
  	 */
  	static draw({
  		start,
  		end,
  		stroke,
  		colour,
  		markers = [],
  		dashes = "",
  		title = ""
  	} = {}) {
  		const offset = stroke*2;	//This offset makes the canvas larger, allowing for wider end markers
  		
  		const xDisplacement = end.x - start.x;
  		const yDisplacement = end.y - start.y;
  		
  		//Default positioning, if we are drawing from origin.
  		const coords = {
  			x1: offset,
  			y1: offset,
  			x2: xDisplacement + offset,
  			y2: yDisplacement + offset
  		};
  		
  		//If X or Y end coords are lower than start, then we need to offset as line is not from origin
  		if (end.x < start.x) {
  			coords.x1 += Math.abs(xDisplacement);
  			coords.x2 += Math.abs(xDisplacement);
  		}
  		
  		if (end.y < start.y) {
  			coords.y1 += Math.abs(yDisplacement);
  			coords.y2 += Math.abs(yDisplacement);
  		}
  		
  		//Position SVG to account for line thickness overflow from origin
  		//E.g. a horizontal line from (0,0) with a thickness of 10 displays from -5 to + 5
  		const xpos = Math.min(start.x,end.x) - offset;
  		const ypos = Math.min(start.y,end.y) - offset;
  		
  		let svg = document.createElementNS(svgns, "svg");
  		svg.setAttribute("width", Math.abs(xDisplacement) + offset*2);
  		svg.setAttribute("height", Math.abs(yDisplacement) + offset*2);
  		svg.setAttribute("style", "position: absolute; left: " + xpos + "px; top: " + ypos + "px");
  		svg.style.color = colour;

  		const line = this.drawLine(coords, stroke, dashes, title);
  		//debugging
  		line.setAttribute("data-coords", `[ ${start.x}, ${start.y} ], [ ${end.x}, ${end.y} ]`);
  		svg.append(line);
  		
  		svg = this._addMarker(svg, markers[0], "start", coords, stroke);
  		svg = this._addMarker(svg, markers[1], "end", coords, stroke);

  		return svg;
  	}
  	
  	/**
  	 * Add a marker to the svg provided at the end specified.
  	 * @param {object} svg
  	 * @param {string} type
  	 * @param {string} pos
  	 * @param {object} coords
  	 * @param {number} stroke
  	 * @return {object|null}
  	 */
  	static _addMarker(svg, type, pos, coords, stroke) {
  		if (type == "circle") svg.append(this._drawCircleMarker(pos, coords, stroke));
  		if (type == "square") svg.append(this._drawSquareMarker(pos, coords, stroke));
  		if (type == "dots" && pos == "end") {
  			svg.setAttribute("width", parseInt(svg.getAttribute("width")) + stroke*2);
  			svg.append(this._drawDotsEnd(coords, stroke));
  		}
  		return svg;
  	}
  	
  	/**
  	 * Draw a square marker at the given position of the line represented by the given coords.
  	 * @param {string} pos - Either "start" or "end"
  	 * @param {object} coords - the four coords of the line
  	 * @param {number} stroke - the stroke width
  	 * @return {object}
  	 */
  	static _drawSquareMarker(pos, coords, stroke) {
  		let [x, y] = [coords.x1 - stroke, coords.y1 - stroke];
  		if (pos == "end") [x, y] = [coords.x2 - stroke, coords.y2 - stroke];
  		return this.drawSquare(x, y, stroke * 2.5);
  	}
  	
  	/**
  	 * Draw a circle marker at the given position of the line represented by the given coords.
  	 * @param {string} pos - Either "start" or "end"
  	 * @param {object} coords - the four coords of the line
  	 * @param {number} stroke - the stroke width
  	 * @return {object}
  	 */
  	static _drawCircleMarker(pos, coords, stroke) {
  		let [x, y] = [coords.x1, coords.y1];
  		if (pos == "end") [x, y] = [coords.x2, coords.y2];
  		return this.drawCircle(x, y, stroke);
  	}
  	
  	/**
  	 * Draw dots marker at the end of the line.
  	 * (Note - requires full line coords, because marker has direction)
  	 * @param {object} coords - the 4 coords of the line being marked
  	 * @param {number} stroke - the stroke width of the line
  	 * @return {object}
  	 */
  	static _drawDotsEnd(coords, stroke) {
  		
  		let x2 = coords.x2;
  		if (coords.x2 < coords.x1) {
  			x2 = coords.x2 - stroke*5;
  		}
  		if (coords.x2 > coords.x1) {
  			x2 = coords.x2 + stroke*5;
  		}
  		
  		let y2 = coords.y2;
  		if (coords.y2 < coords.y1) {
  			y2 = coords.y2 - stroke*2;
  		}
  		if (coords.y2 > coords.y1) {
  			y2 = coords.y2 + stroke*2;
  		}
  		
  		const dotCoords = {
  			x1: coords.x2,
  			y1: coords.y2,
  			x2: x2,
  			y2: y2
  		};
  		return this.drawLine(dotCoords, stroke, `0 ${stroke} ${stroke} ${stroke} ${stroke}`);
  	}
  	
  	/**
  	 * Returns an SVG line, which can be appended to an SVG element.
  	 * @param {object} coords - the x and y coordinates of the start and end points of the line
  	 * @param {number} coords.x1
  	 * @param {number} coords.y1
  	 * @param {number} coords.x2
  	 * @param {number} coords.y2
  	 * @param {number} width - The width in px of the line
  	 * @param {string} [dashes] - The dasharray pattern of the line. If omitted, it will be solid.
  	 * 		Must be a valid SVG dasharray (@see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray})
  	 * @param {String} [title] - If included, a title element will be included with the given text.
  	 * @return {object}
  	 */
  	static drawLine(coords, width, dashes = "", title = "") {
  		const line = document.createElementNS(svgns, "line");
  		line.setAttribute("x1", coords.x1);
  		line.setAttribute("y1", coords.y1);
  		line.setAttribute("x2", coords.x2);
  		line.setAttribute("y2", coords.y2);
  		line.setAttribute("stroke-width", width);
  		line.setAttribute("stroke-dasharray",dashes);
  		line.setAttribute("stroke", "currentColor");
  		
  		if(title) {
  			line.append(this._createTitle(title));
  		}
  		return line;
  	}
  	
  	/**
  	 * Return an SVG circle, which can be appended to an SVG element.
  	 * @param {number} cx - The X coordinate of the circle centre
  	 * @param {number} cy - The Y coordinate of the circle centre
  	 * @param {number} r - The radius in px of the circle
  	 * @param {String} [title] - If included, a title element will be included with the given text.
  	 * @return {object}
  	 */
  	static drawCircle(cx, cy, r, title = "") {
  		const circle = document.createElementNS(svgns, "circle");
  		circle.setAttribute("cx", cx);
  		circle.setAttribute("cy", cy);
  		circle.setAttribute("r", r);
  		circle.setAttribute("fill", "currentColor");
  		
  		if(title) {
  			circle.append(this._createTitle(title));
  		}
  		
  		return circle;
  	}
  	
  	/**
  	 * Returns an SVG square, which can be appended to an SVG element.
  	 * @param {number} x - The X coordinate
  	 * @param {number} y - The y coordinate
  	 * @param {number} w - The width of the square
  	 * @param {String} [title] - If included, a title element will be included with the given text.
  	 * @return {object}
  	 */
  	static drawSquare(x, y, w, title = "") {
  		const square = document.createElementNS(svgns, "rect");
  		square.setAttribute("x", x);
  		square.setAttribute("y", y);
  		square.setAttribute("width", w);
  		square.setAttribute("height", w);
  		square.setAttribute("fill", "currentColor");
  		
  		if(title) {
  			square.append(this._createTitle(title));
  		}
  		
  		return square;
  	}
  	
  	/**
  	 * Create a title element with the given title
  	 * @param {string} title
  	 * @return {object}
  	 */
  	static _createTitle(title) {
  		
  		const t = document.createElementNS(svgns, "title");
  		t.append(document.createTextNode(title));
  		t.dataset.title = title;
  		console.log(title);
  		return t;
  	}
  }

  /**
   * Calculates an available position for diagram entries which have not had their row (Y-axis position) set manually.
   * This is fairly rudimentary - a row with sufficient empty space for each entry (and any it joins directly with) will be calculated.
   * If the entry splits from or merges with other entries, the nearest row to those entries will be sought.
   * This is most effectively used in a hybrid form, using some manual positioning, allowing simpler cases to be positioned automatically.
   */
  class DiagramPositioner {
  	
  	/**
  	 * @param {number} years - Length of the timeline in years.
  	 * @param {number} [yearStart=1900] - The first year of the timeline.
  	 * @param {number} [rows] - The number of rows currently in the timeline (used for mixed manual and auto positioning).
  	 */
  	constructor(years, yearStart = 1900, rows = 1) {
  		this._years = years;
  		this._yearStart = yearStart;
  		this._grid = Array.from(Array(rows+1), () => new Array(years).fill(false));
  	}
  	
  	/**
  	 * Set the row for the provided entry.
  	 * @param {HTMLElement} entry
  	 */
  	setEntryRow(entry) {
  		const start = this._yearToGrid(entry.dataset.start);
  		const end = this._yearToGrid(this._calcGroupEnd(entry));
  		let seek = null, near = null;
  		
  		if (entry.dataset.split) {
  			seek = document.getElementById(entry.dataset.split);
  		}
  		
  		if (entry.dataset.merge) {
  			const mergeEl = document.getElementById(entry.dataset.merge);
  			
  			//Prevent infinite recursion if merging with an entry which split from this one
  			if(mergeEl.dataset.split !== entry.id) {
  				seek = mergeEl;
  			}
  		}
  		
  		if (seek && near === null) {
  			if (!seek.dataset.row) {
  				this.setEntryRow(seek);
  			}
  			near = parseInt(seek.dataset.row);
  		}
  		
  		const row = this._calcEntryRow(entry, start, end, near);
  		entry.dataset.row = row;
  		this._setGroupRow(entry);
  		try {
  			this._blockGridSpace(row, start, end);
  		} catch(e) {
  			console.log(`${e}: called for ${entry.id} with row ${row}`);
  		}
  	}
  	
  	/**
  	 * Provide the grid X number for a given year
  	 * @param {number} year
  	 * @return {number}
  	 */
  	_yearToGrid(year) {
  		return parseInt(year) - parseInt(this._yearStart);
  	}
  	
  	/**
  	 * Get the number of rows in the diagram.
  	 * @return {number}
  	 */
  	get rows() {
  		return this._grid.length;
  	}
  	
  	/**
  	 * Set the row on entries grouped with the current entry
  	 * @protected
  	 * @param {HTMLElement} entry
  	 */
  	_setGroupRow(entry) {
  		if (entry.dataset.become) {
  			const next = document.getElementById(entry.dataset.become);
  			
  			if(next.dataset.row) {
  				const s = next.dataset.start - this._yearStart;
  				const e = next.dataset.end - this._yearStart;
  				this._freeGridSpace(next.dataset.row, s, e);
  			}
  			next.dataset.row = entry.dataset.row;
  			this._setGroupRow(next);
  		}
  	}
  	
  	/**
  	 * Calculate a suitable row for an entry and return it.
  	 * @protected
  	 * @param {HTMLElement} entry - the entry
  	 * @param {number} start - the number of units (years) from the start of the X axis the entry must start
  	 * @param {number} end - the number of units (years) from the start of the X axis the entry must end
  	 * @param {HTMLElement} near - Another entry this entry should try to be near
  	 * @return {number}
  	 */
  	_calcEntryRow(entry, start, end, near = null) {
  		if (entry.dataset.row) {
  			return entry.dataset.row;
  		}
  		if (near) {
  			return this._findNearestGridSpace(parseInt(near), start, end);
  		}
  		return this._findGridSpace(start, end);
  	}
  	
  	/**
  	 * Calculate the end year of an entry's group (i.e. the end of the last entry to which it directly joins).
  	 * @protected
  	 * @param {HTMLElement} entry
  	 * @return {number}
  	 */
  	_calcGroupEnd(entry) {
  		let end = entry.dataset.end;
  		if (entry.dataset.become) {
  			end = this._calcGroupEnd(document.getElementById(entry.dataset.become));			
  		}
  		return end;
  	}
  	
  	/**
  	 * Find a row in the grid with space between the provided start and end points.
  	 * @protected
  	 * @param {number} start
  	 * @param {number} end
  	 * @return {number}
  	 */
  	_findGridSpace(start, end) {
  		for (let i = 0; i < this.rows; i++) {
  			if (this._checkGridSpace(i, start, end)) {
  				return i;
  			}
  		}
  		this._addGridRow();
  		return this.rows - 1;
  	}
  	
  	/**
  	 * Find the nearest row to that provided which is empty between start and end.
  	 * @protected
  	 * @param {number} y
  	 * @param {number} start
  	 * @param {number} end
  	 */
  	_findNearestGridSpace(y, start, end) {
  		let before = y, after = y;
  		
  		if (this._checkGridSpace(y, start, end)) { return y; }
  		
  		while(before > -1 && !this._checkGridSpace(before, start, end)) { before--; }
  		while(after < this.rows && !this._checkGridSpace(after, start, end)) { after++; }
  		
  		if (before == -1 && after == this.rows) {
  			this._addGridRow();
  			return this.rows - 1;
  		}
  		
  		if (after == this.rows) { return before; }
  		
  		if (before == -1) { return after; }
  		
  		if ((y - before) <= (after - y)) { return before; }
  		else { return after; }
  	}
  	
  	/**
  	 * Add a row to the grid.
  	 * @protected
  	 */
  	_addGridRow() {
  		this._grid.push(new Array(this._years).fill(false));
  	}
  	
  	/**
  	 * Check if the given row y is empty between start and end.
  	 * @protected
  	 * @param {number} y
  	 * @param {number} start
  	 * @param {number} end
  	 * @return {boolean}
  	 */
  	_checkGridSpace(y, start, end) {
  		//In most instances, we don't want to extend to the end of the "end" year, but to the start. So that, e.g. we can join with another entry starting on that year and not overlap.  However, entries with the same start and end must take up some space.
  		if (start === end) {
  			end += 1;
  		}
  		
  		const part = this._grid[y].slice(start, end);
  		let result = part.every( e => e === false);
  		return result;
  	}
  	
  	/**
  	 * Set the space in row y from start to end as full.
  	 * @protected
  	 * @param {number} y
  	 * @param {number} start
  	 * @param {number} end
  	 */
  	_blockGridSpace(y, start, end) {
  		this._markGridSpace(y, start, end, true);
  	}
  	
  	/**
  	 * Set the space in row y from start to end as empty.
  	 * @protected
  	 * @param {number} y
  	 * @param {number} start
  	 * @param {number} end
  	 */
  	_freeGridSpace(y, start, end) {
  		this._markGridSpace(y, start, end, false);
  	}
  	
  	/**
  	 * Set the space in row y from start to end according to the state param.
  	 * @protected
  	 * @param {number} y
  	 * @param {number} start
  	 * @param {number} end
  	 * @param {boolean} state
  	 */
  	_markGridSpace(y, start, end, state) {
  		if (!this._grid[y]) {
  			throw new Error(`Attempt to mark non-existent grid row ${y}`);
  		}
  		let n = 0;
  		while (n < (end - start)) {
  			this._grid[y][start+n] = state;
  			n++;
  		}
  		
  		//Mark space either end to keep entries from joining, if available
  		if (start > 0) {
  			this._grid[y][start-1] = state;
  		}
  		if (end < this._grid[0].length - 1) {
  			this._grid[y][end] = state;
  		}
  	}
  }

  /**
   * Takes a config object and a default config object and returns a final config with all config modifcations applied.
   * Ensures no unwanted properties are passed in config.
   * @param {object} defaults - The default config object with all allowed properties
   * @param {object} conf - The config object to apply
   * @return {object}
   */
  function applyConfig(defaults, conf) {
  	let c = {};
  	
  	for (const prop in defaults) {
  		if(conf.hasOwnProperty(prop)) {
  			c[prop] = conf[prop];
  		} else {
  			c[prop] = defaults[prop];
  		}
  	}
  	return c;
  }

  /**
   * The default configuration object for the Diagram class
   */
  const defaultDiagramConfig = {
  	yearStart: 1900,
  	yearEnd: new Date().getFullYear() + 1,
  	strokeWidth: 4,
  	yearWidth: 50,
  	rowHeight: 50,
  	padding: 5,
  	boxWidth: 100,
  	guides: true,
  	guideInterval: 5,
  	entrySelector: "div",
  	linkDashes: "4",
  	irregularDashes: "88 4 4 4"
  };

  /**
   * Class representing the timeline diagram drawing area. This is used by the main Timeline class.
   * The diagram is drawn by instanciating this class and calling create() on the instance.
   */
  class Diagram {
  	
  	/**
  	 * Create a diagram.
  	 * @param {string} container - The ID of the container element for the diagram.
  	 * @param {object} config - Configuration object for the diagram. Entirely optional.
  	 * @param {number} [config.yearStart = 1900] - the starting year for the timeline
  	 * @param {number} [config.yearEnd = Current year + 1] - the end year for the timeline
  	 * @param {number} [config.strokeWidth = 4] - the width in px of the joining lines
  	 * @param {number} [config.yearWidth = 50] - the width in px of diagram used to for each year
  	 * @param {number} [config.rowHeight = 50] - the height in px of each diagram row
  	 * @param {number} [config.padding = 5] - the padding in px between rows
  	 * @param {number} [config.boxWidth = 100] - the width in px of each entry
  	 * @param {boolean} [config.guides = true] - whether to draw striped guides at regular intervals in the timeline
  	 * @param {number} [config.guideInterval = 5] - the interval in years between guides (ignored if 'guides' is false)
  	 * @param {string} [config.entrySelector = "div"] - the CSS selector to match entries
  	 * @param {string} [config.linkDashes = "4"] - The svg dasharray for link lines.
  	 * 								Must be a valid dasharray. See <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray>
  	 * @param {string} [config.irregularDashes = "20 2"] - The svg dasharray for entries marked as 'irregular' with the data-irregular attribute.
  	 * 								Must be a valid dasharray. See <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray>
  	 */
  	constructor(container, config = {}) {		
  		this._config = this._makeConfig(config);
  		this._applyCSSProperties();
  		this._container = document.getElementById(container);
  		this._entries = document.querySelectorAll("#" + container + " > " + this._config.entrySelector+":not(.timeline-exclude):not(.event)");
  		this._events = this._container.querySelectorAll(".event");
  	}
  	
  	/**
  	 * Take the given config, apply defaults and return final config object.
  	 * @protected
  	 * @param {object} config
  	 * @return {object}
  	 */
  	_makeConfig(config) {
  		const c = applyConfig(defaultDiagramConfig, config);
  		//Derived settings for convenience
  		c.boxHeight = c.rowHeight - c.padding*2;
  		c.boxMinWidth = c.boxHeight;
  		return c;
  	}
  	
  		
  	/**
  	 * Set a single config property.
  	 * @protected
  	 * @param {string} prop
  	 * @param {string} value
  	 */
  	_setConfigProp(prop, value) {
  		this._config[prop] = value;
  	}
  	
  	/** Create the timeline.
  	 * This should be called after creating a class instance.
  	 */
  	create() {
  		this._setup();
  		this._draw();
  		this._addDates();
  		if (this._config.guides === true) {
  			this._addGuides();
  		}
  		return this._container;
  	}
  	
  	/** Setup necessary CSS classes and data for entries.
  	 * @protected
  	 */
  	_setup() {
  		this._prepareEntries();
  		this._prepareRows();
  		
  		//Set up container
  		this._container.classList.add("timeline-container");
  		this._container.style.height = (this._config.rows + 2) * this._config.rowHeight + "px"; //Add 2 rows to total for top and bottom space
   		this._container.style.width = (this._config.yearEnd + 1 - this._config.yearStart) * this._config.yearWidth + "px"; //Add 1 year for padding
  	
  		this._setEntries();
  		this._setEvents();
  	}
  	
  	/** Prepare all entries with initial classes and data
  	 * @protected
  	 */
  	_prepareEntries() {
  		for (const entry of this._entries) {
  			entry.classList.add("entry");
  			entry.dataset.end = this._calcEnd(entry);
  			
  			//If start is before Timeline start, then move it and add a class.
  			if (parseInt(entry.dataset.start) < this._config.yearStart) {
  				entry.classList.add("preexists");
  				entry.dataset.start = this._config.yearStart;
  			}
  			
  			//Validate all referenced IDs and warn if missing.
  			for (const attrib of [ "become", "split", "merge", "links" ]) {
  				if (entry.dataset.hasOwnProperty(attrib)) {
  					for (const id of entry.dataset[attrib].split(" ")) {
  						if (!document.getElementById(id)) {
  							console.warn(`${entry.id}: Given ${attrib} ID "${id}" doesn't exist. Ignoring.`);
  							delete entry.dataset[attrib];
  						}
  					}
  				}
  			}
  		}
  	}
  	
  	/**
  	 * Set the row for all entries, using automatic diagramPositioner if available
  	 * @protected
  	 */
  	_prepareRows() {
  		let rows = 1;
  		
  		//Find the highest manual row number
  		for (const entry of this._entries) {
  			if (parseInt(entry.dataset.row) > rows) {
  				rows = parseInt(entry.dataset.row);
  			}
  		}

  		//If we are using the positioner only (otherwise must be manually set)
  		if (typeof DiagramPositioner === "function") {
  			const years = this._config.yearEnd - this._config.yearStart;
  			const dp = new DiagramPositioner(years, this._config.yearStart, rows);
  			
  			for (const entry of this._entries) {
  				dp.setEntryRow(entry);
  			}
  			rows = dp.rows;
  		}
  		this._setConfigProp("rows", rows);
  	}
  	
  	/**
  	 * Set styles for each entry to position them according to calculated row and entry size
  	 * @protected
  	 */
  	_setEntries() {
  		//Position entries and add additional data
  		for (const entry of this._entries) {
  			entry.style.left = this._yearToWidth(entry.dataset.start) + "px";
  			entry.style.top = this._calcTop(entry) + "px";
  			if (entry.dataset.colour) {
  				entry.style.borderColor = entry.dataset.colour;
  			}
  			
  			//Style short entries (lasting less time than the box size)
  			if(this._checkSmallEntry(entry) === true) {
  				entry.classList.add("min");
  			}
  		}
  		
  		//Adjust spacing for entries that overlap
  		//Accommodates entries that are both the same year
  		//Width needs to be known before nudging, so this has to be separated
  		for (const entry of this._container.querySelectorAll(this._config.entrySelector + '[data-become]')) {
  			if (entry.dataset.start == document.getElementById(entry.dataset.become).dataset.start) {
  				entry.style.left = parseFloat(entry.style.left) - this._config.boxMinWidth/2 + "px";
  				document.getElementById(entry.dataset.become).style.left = parseFloat(document.getElementById(entry.dataset.become).style.left) + this._config.boxMinWidth/2 + "px";
  			}
  		}
  	}
  	
  	/**
  	 * Set styles for each event to correctly position them
  	 * @protected
  	 */
  	_setEvents() {
  		for (const event of this._events) {
  			if (event.dataset.target && !document.getElementById(event.dataset.target)) {
  				console.warn(`Event has an invalid target, which will be ignored: ${JSON.stringify(event)}`);
  			}
  			
  			let top = this._config.rowHeight - event.offsetHeight;
  			let left = this._yearToWidth(event.dataset.year);
  			
  			//Wrap content in a span for easier styling
  			const span = document.createElement("span");
  			span.dataset.year = event.dataset.year; //Allows using value in CSS content on span.
  			span.innerText = event.innerText;
  			event.innerText = "";
  			event.append(span);
  			
  			if (event.dataset.target) {
  				const target = document.getElementById(event.dataset.target);
  				top = this._calcTop(target) + ((this._config.boxHeight - event.offsetHeight) * 0.5);
  				left = left - (event.offsetWidth * 0.5);
  				
  				//Match the target colour. Add style to head instead of inline to avoid over-riding the hover/focus colours (simpler than lots of event listeners).
  				if (target.dataset.colour) {
  					const css = document.createTextNode(`.event[data-target="${target.id}"] {border-color: ${target.dataset.colour}; color: ${target.dataset.colour}; background-color: ${target.dataset.colour};}`);
  					if (!document.getElementById("tl-styles")) {
  						const s = document.createElement("style");
  						s.id = "tl-styles";
  						s.setAttribute('type', 'text/css');
  						document.head.append(s);
  					}
  					document.getElementById("tl-styles").append(css);
  				}
  			}
  			
  			event.style.left = left + "px";
  			event.style.top = top + "px";
  		}
  	}
  	
  	/**
  	 * Add the date timelines to top and bottom of the diagram
  	 * @protected
  	 */
  	_addDates() {
  		const tl = document.createElement("div");
  		tl.classList.add("dates");
  		
  		let y = this._config.yearStart;
  		while(y < this._config.yearEnd) {
  			const d = document.createElement("date");
  			d.style.left = this._yearToWidth(y) + "px";
  			const t = document.createTextNode(y);
  			d.append(t);
  			tl.append(d);
  			y = y+5;
  		}
  		this._container.prepend(tl);
  		
  		const tl2 = tl.cloneNode(true);
  		tl2.style.top = (this._config.rows) * this._config.rowHeight + "px";
  		this._container.append(tl2);
  	}
  	
  	/**
  	 * Add striped guides to the diagram.
  	 * @protected
  	 */
  	_addGuides() {
  		let y = this._config.yearStart;

  		//Round the end up to the nearest multiple of guideInterval to ensure last guide is placed.
  		while(y < Math.ceil(this._config.yearEnd/this._config.guideInterval)*this._config.guideInterval) {
  			const guide = document.createElement("div");
  			guide.classList.add("guide");
  			guide.style.left = this._yearToWidth(y) + "px";
  			guide.style.width = this._config.yearWidth * this._config.guideInterval + "px";
  			
  			if(((y - this._config.yearStart) / this._config.guideInterval) % 2 == 1) {
  				guide.classList.add("odd");
  			}
  			
  			this._container.append(guide);
  			y = y + this._config.guideInterval;
  		}
  	}
  		
  	/** Draw all lines in the timeline between entries.
  	 * @protected
  	 */
  	_draw() {
  		for (const entry of this._entries) {
  			
  			const colour = (entry.dataset.colour ? entry.dataset.colour : "var(--tl-colour-stroke)");
  			const dasharray = (entry.dataset.irregular == "true" ? this._config.irregularDashes : "");
  			
  			let endMarker = "";
  			let cssClass = "end";
  			let start = this._getJoinCoords(entry, "right");
  			let end = {
  				x: this._yearToWidth(entry.dataset.end),
  				y: start.y
  			};
  			
  			//Ends without joining another entry
  			if (!entry.dataset.hasOwnProperty("merge") &&
  				!entry.dataset.hasOwnProperty("become")
  			) {
  				endMarker = (entry.dataset.endEstimate ? "dots" : "circle");
  			}
  			
  			if (entry.dataset.hasOwnProperty("become")) { 
  				end = this._getJoinCoords(document.getElementById(entry.dataset.become), 'left');
  				cssClass = "become";
  			}
  			
  			if (entry.dataset.hasOwnProperty("merge")) {
  				//Special case of one year length and then merging. We need to bump the merge eventnt forward by 1 year to meet an 'end of year' eventnt. Otherwise, it's indistinguishable from a split.
  				if (entry.dataset.start == entry.dataset.end) {
  					end.x += this._config.yearWidth;
  				}
  				
  				const mergePoint = {
  					x: end.x,
  					y: this._getYCentre(document.getElementById(entry.dataset.merge))
  				};
  				
  				//Merged entry's line ends a bit earlier, so as to go diagonally to meet the other entry at the year mark.
  				end.x = end.x - this._config.yearWidth;
  				const merge = SvgConnector.draw({ start: end, end: mergePoint, stroke: this._config.strokeWidth, colour: colour });
  				merge.classList.add("merge");
  				this._container.append(merge);
  				cssClass = "merge";
  			}
  				
  			//Nothing to draw here if entry starts and ends on the same year
  			if (entry.dataset.start !== entry.dataset.end) {
  				const line = SvgConnector.draw({ start: start, end: end, stroke: this._config.strokeWidth, colour: colour, markers: ["", endMarker], dashes: dasharray });
  				line.classList.add(cssClass);
  				this._container.append(line);
  			}

  			if (entry.dataset.hasOwnProperty("split")) {
  				this._drawSplit(entry, colour);
  			}
  			if (entry.dataset.hasOwnProperty("links")) {
  				this._drawLinks(entry, colour);
  			}
  		}
  	}
  	
  	/**
  	 * Draw splits.
  	 * @protected
  	 * @param {HTMLElement} entry
  	 * @param {string} colour
  	 */
  	_drawSplit(entry, colour) {
  		const source = document.getElementById(entry.dataset.split);
  		
  		let direction = "top";
  		if (parseInt(entry.dataset.row) < parseInt(source.dataset.row)) {
  			direction = "bottom";			
  		}
  		
  		const start = {
  			x: this._yearToWidth(entry.dataset.start),
  			y: this._getYCentre(source)
  		};
  		const end = this._getJoinCoords(entry, direction);
  		
  		const line = SvgConnector.draw( { start: start, end: end, stroke: this._config.strokeWidth, colour: colour });
  		
  		line.classList.add("split");
  		this._container.append(line);
  	}
  	
  	/**
  	 * Draw links.
  	 * @protected
  	 * @param {HTMLElement} entry
  	 * @param {string} colour
  	 */
  	_drawLinks(entry, colour) {
  		const links = entry.dataset.links.split(" ");
  		
  		//Count links drawn on each side, so additional ones can be offset to avoid overlap.
  		let indices = {
  			top: -1,
  			bottom: -1,
  			left: -1,
  			right: -1
  		};
  		
  		for (const link of links) {
  			const target = document.getElementById(link);			
  			let sourceSide, targetSide, start = { x: 0, y: 0}, end = { x: 0, y: 0};
  			
  			const eRow = parseInt(entry.dataset.row);
  			const tRow = parseInt(target.dataset.row);
  			
  			//Find the direction of the link
  			if (eRow === tRow && entry.dataset.start < target.dataset.start) {
  				indices["right"] = indices["right"]+1;
  				sourceSide = "right";
  				targetSide = "left";
  			}
  			if (eRow === tRow && entry.dataset.start > target.dataset.start) {
  				indices["left"] = indices["left"]+1;
  				sourceSide = "left";
  				targetSide = "right";
  			}
  			if (eRow > tRow) {
  				indices["top"] = indices["top"]+1;
  				sourceSide = "top";
  				targetSide = "bottom";
  			}
  			if (eRow < tRow) {
  				indices["bottom"] = indices["bottom"]+1;
  				sourceSide = "bottom";
  				targetSide = "top";
  			}
  			
  			start = this._getJoinCoords(entry, sourceSide, indices[sourceSide]);
  			
  			//Start with vertical line to line case
  			end = {
  				x: start.x,
  				y: this._getYCentre(target)
  			};
  			
  			//If the target doesn't overlap in time with the source (can't be after, as link would be vice versa then)
  			if(entry.dataset.start >= target.dataset.end) {
  				end.x = this._yearToWidth(target.dataset.end);
  			}
  			
  			//If the year is the same, link the entry box, not the line
  			if(entry.dataset.start == target.dataset.start) {
  				end = this._getJoinCoords(target, targetSide);
  			}
  			
  			const connector = SvgConnector.draw({
  				start: start,
  				end: end,
  				stroke: this._config.strokeWidth/2,
  				colour: colour,
  				markers: ["square", "square"],
  				dashes: this._config.linkDashes
  			});
  			connector.classList.add("link");
  			this._container.append(connector);
  		}
  	}
  	
  	/** Add CSS properties to document root, based on config.
  	 * @protected
  	 */
  	_applyCSSProperties() {
  		const root = document.documentElement;
  		root.style.setProperty('--tl-width-year', this._config.yearWidth + "px");
  		root.style.setProperty('--tl-height-row', this._config.rowHeight + "px");
  		root.style.setProperty('--tl-width-box', this._config.boxWidth + "px");
  		root.style.setProperty('--tl-height-box', this._config.boxHeight + "px");
  		root.style.setProperty('--tl-width-box-min', this._config.boxHeight + "px");
  		root.style.setProperty('--tl-padding', this._config.padding + "px");
  	}
  	
  	/**
  	 * Find and return the coordinates where lines should join an element on each side.
  	 * Where multiple lines are meeting an element on one side, specifying the offest number
  	 * allows these to join at different eventnts.
  	 * @protected
  	 * @param {HTMLElement} entry
  	 * @param {string} side - Must be "top", "bottom", "left" or "right"
  	 * @param {number} offset - the number of steps to offset the eventnt (use if multiple lines join an entry on the same side).
  	 * @return {object}
  	 */
  	_getJoinCoords(entry, side, offset = 0) {
  		
  		const offsetIncrement = 5;
  		
  		const status = window.getComputedStyle(entry);
  		
  		const l = parseFloat(entry.style.left);
  		const t = parseFloat(entry.style.top);
  		const w = parseFloat(status.getPropertyValue('width'));
  		const h = parseFloat(status.getPropertyValue('height'));
  		
  		switch(side) {
  			case 'left':
  				return {
  					x: l,
  					y: t + h/2 + (offset * offsetIncrement)
  				};
  			case 'right':
  				return {
  					x: l + w,
  					y: t + h/2 + (offset * offsetIncrement)
  				};
  			case 'top':
  				return {
  					x: l + w/2 + (offset * offsetIncrement),
  					y: t
  				};
  			case 'bottom':
  				return {
  					x: l + w/2 + (offset * offsetIncrement),
  					y: t + h
  				};
  			default:
  				throw `Invalid element side specified: Called with ${side}. Entry: ${entry}`;
  		}
  	}
  	
  	/**
  	 * Return the end date for an entry, whether explicitly set or not.
  	 * @protected
  	 * @param {HTMLElement} entry
  	 * @return {number}
  	 */
  	_calcEnd(entry) {
  		if (entry.dataset.end) {
  			return parseInt(entry.dataset.end);
  		}
  		
  		if (entry.dataset.become) {
  			return parseInt(document.getElementById(entry.dataset.become).dataset.start);
  		}
  		
  		return parseInt(this._config.yearEnd);
  	}
  	
  	/**
  	 * Calculate the absolute top position in px.
  	 * @protected
  	 * @param {HTMLElement} entry
  	 * @return {number}
  	 */
  	_calcTop(entry) {
  		 //Add 1 to row due to 0 index.
  		return parseInt((parseInt(entry.dataset.row) +1) * this._config.rowHeight + this._config.padding)
  	}

  	/**
  	 * Check if an entry should be small on the graph (too brief to fit full box size)
  	 * @protected
  	 * @param {HTMLElement} entry
  	 * @return {boolean}
  	 */
  	_checkSmallEntry(entry) {
  		const start = entry.dataset.start;
  		const end = entry.dataset.end;
  		
  		if ((end - start) < (this._config.boxWidth/this._config.yearWidth)) {
  			return true;
  		} else {
  			return false;
  		}
  	}
  	
  	/**
  	 * Get the X-axis centre of an entry box.
  	 * @protected
  	 * @param {HTMLElement} entry
  	 * @return {number}
  	 */
  	_getXCentre(entry) {
  		return parseFloat(entry.style.left) + (this._config.boxWidth/2);
  	}
  	
  	/**
  	 * Get the Y-axis centre of an entry box.
  	 * @protected
  	 * @param {HTMLElement} entry
  	 * @return {number}
  	 */
  	_getYCentre(entry) {
  		return parseFloat(entry.style.top) + (this._config.boxHeight/2);
  	}
  	
  	/**
  	 * Get the width in px of the diagram at the eventnt sepecified by a particular year.
  	 * @param {number} year
  	 * @protected
  	 * @return {number}
  	 */
  	_yearToWidth(year) {
  		return parseInt((year - this._config.yearStart) * this._config.yearWidth);
  	}
  }

  /** Timeline
   *Copyright (C) 2021 Aonghus Storey
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */

  /**
   * The default configuration object for the Timeline
   */
  const defaultTimelineConfig = {
  	panzoom: null,
  	findForm: "timeline-find",
  	zoomIn: "timeline-zoom-in",
  	zoomOut: "timeline-zoom-out",
  	zoomReset: "timeline-zoom-reset"
  };

  /**
   * The class representing the Timeline.  This is the point of access to this tool.
   * The simplest usage is to instantiate a new Timeline object, and then call the create() method.
   * @alias Timeline
   */
  class Timeline {
  	/**
  	 * @param {string} [container = diagram] - The ID of the container element for the timeline.
  	 * @param {object} [config] - All config for the timeline
  	 * @param {(function|null)} [config.panzoom = null] - The Panzoom function to enable panning and zooming, or null to disable
  	 * @param {string} [config.findForm = timeline-find] - The ID of the find form
  	 * @param {string} [config.zoomIn = timeline-zoom-in] - The ID of the button to zoom in
  	 * @param {string} [config.zoomOut = timeline-zoom-out] - The ID of the button to zoom out
  	 * @param {string} [config.zoomReset = timeline-zoom-reset] - The ID of the button to reset the zoom level
  	 * @param {number} [config.yearStart = 1900] - the starting year for the timeline
  	 * @param {number} [config.yearEnd = Current year + 1] - the end year for the timeline
  	 * @param {number} [config.strokeWidth = 4] - the width in px of the joining lines
  	 * @param {number} [config.yearWidth = 50] - the width in px of diagram used for each year
  	 * @param {number} [config.rowHeight = 50] - the height in px of each diagram row
  	 * @param {number} [config.padding = 5] - the padding in px between rows
  	 * @param {number} [config.boxWidth = 100] - the width in px of each entry
  	 * @param {boolean} [config.guides = true] - whether to draw striped guides at regular intervals in the timeline
  	 * @param {number} [config.guideInterval = 5] - the interval in years between guides (ignored if 'guides' is false)
  	 * @param {string} [config.entrySelector = div] - the CSS selector used for entries
  	 * @param {object[]} [entries = []] - The Timeline entries as an array of objects
  	 * @param {object[]} [events = []] - Events as an array of objects
  	 */
  	constructor(container = "diagram", config = {}, entries = [], events = []) {
  		this._container = container;
  		this._setConfig(config);
  		
  		for (const entry of entries) {
  			this.addEntry(entry);
  		}
  		for (const event of events) {
  			this.addEvent(event);
  		}
  	}
  	
  	/**
  	 * Create the Timeline. This should be called after instantiation.
  	 * @public
  	 */
  	create() {
  		const d = new Diagram(this._container, this._diagramConfig);
  		this._diagram = d.create();

  		if (typeof this._config.panzoom === "function") {
  			this._initPanzoom();
  			this._initControls();
  			window.addEventListener('hashchange', (e) => this._hashHandler(e));
  		}
  		if (location.hash) {
  			setTimeout(() => {
  				this._hashHandler();
  			});
  		}
  	}
  	
  	/**
  	 * Take the provided config, separate config for the Diagram drawing class, and add in defaults for undefined properties.
  	 * @protected
  	 * @param {object} config
  	 */
  	_setConfig(config) {
  		this._config = applyConfig(defaultTimelineConfig, config);
  		this._diagramConfig = applyConfig(defaultDiagramConfig, config);
  	}
  	
  	/**
  	 * Add a single entry from an object.
  	 * @protected
  	 * @param {object} data
  	 */
  	addEntry(data) {
  		if (document.getElementById(data.id)) {
  			console.warn(`Invalid entry: ${data.id} already exists.`);
  			return;
  		}
  		if (![ "id", "name", "start" ].every((i) => data.hasOwnProperty(i))) {
  			console.warn(`Invalid entry: ${JSON.stringify(data)}. Entries must have at least id, name and start values.`);
  			return;
  		}
  		
  		const entry = document.createElement("div");
  		entry.id = data.id;
  		entry.innerText = data.name;
  		for (const k of Object.keys(data)) {
  			if (["id", "name"].includes(k)) continue;
  			entry.dataset[k] = data[k];
  		}
  		document.getElementById(this._container).append(entry);
  	}
  	
  	/**
  	 * Add a single event from an object.
  	 * @protected
  	 * @param {object} data
  	 */
  	addEvent(data) {
  		if (!data.year || ! data.content) {
  			console.warn(`Invalid event: ${JSON.stringify(data)}. Events must have at least a year and content property.`);
  			return;
  		}
  		
  		const event = document.createElement("div");
  		event.classList.add("event");
  		event.innerText = data.content;
  		for (const k of Object.keys(data)) {
  			if (k == "content") continue;
  			event.dataset[k] = data[k];
  		}
  		document.getElementById(this._container).append(event);
  	}
  	
  	/**
  	 * If Panzoom is enabled, pan to the element with the given ID, and reset the zoom.
  	 * @public
  	 * @param {string} id - The ID of a timeline entry
  	 * @fires Timeline#timelineFind
  	 */
  	panToEntry(id) {
  		if (typeof this._pz === "undefined") {
  			throw new Error("Panzoom module missing. Include Panzoom to use the pan-to-entry feature.");
  		}
  		
  		const target = document.getElementById(id);
  		const x = window.innerWidth/2 - parseInt(target.style.left) - this._diagramConfig.boxWidth/2;
  		const y = window.innerHeight/2 - parseInt(target.style.top) - this._diagramConfig.rowHeight/2;
  				
  		this._pz.zoom(1);
  		this._pz.pan(x, y);
  		
  		const tlFind = new CustomEvent('timelineFind', { detail: { id: id, name: target.innerText } });
  		document.getElementById(this._container).dispatchEvent(tlFind);
  		
  		setTimeout( () => { target.classList.add("highlight", "hover"); }, 500);	
  		setTimeout( () => { target.classList.remove("highlight", "hover"); }, 2000);
  	}
  	
  	/**
  	 * The timelineFind event is fired when panToEntry() is called. (Only applicable if Panzoom is enabled).
  	 * @event Timeline#timelineFind
  	 * @type {object}
  	 * @public
  	 * @property {object} details
  	 * @property {string} details.id - the ID of the entry
  	 * @property {string} details.name - the name of the entry
  	 */
  	
  	/**
  	 * Bind the zoom controls to the configured element IDs, if present in the document.
  	 * Prepare empty container for entry filter if find form is present.
  	 * @protected
  	 */
  	_initControls() {
  		const zoomIn = document.getElementById(this._config.zoomIn);
  		const zoomOut = document.getElementById(this._config.zoomOut);
  		const reset = document.getElementById(this._config.zoomReset);
  		const find = document.getElementById(this._config.findForm);
  		
  		if(zoomIn) { zoomIn.addEventListener("click", this._pz.zoomIn); }
  		if(zoomOut) { zoomOut.addEventListener("click", this._pz.zoomOut); }
  		if(reset) { reset.addEventListener("click", () => this._pz.zoom(1)); }
  		if(find) {
  			this._initFindForm(find);
  		}
  	}
  	
  	/**
  	 * Set up the find form
  	 * @protected
  	 */
  	_initFindForm(form) {
  		//Add the ID input
  		const idInput = document.createElement("input");
  		idInput.name = "find-id";
  		idInput.style.display = "none";
  		form.append(idInput);
  		
  		//Add the wrappers and container for the filtering results
  		const finder = form.querySelector("input[name=finder]");
  		const wrap = document.createElement("div");
  		const inner = document.createElement("div");
  		const results = document.createElement("ul");
  		wrap.classList.add("filtered-entries");
  		wrap.appendChild(inner);
  		inner.appendChild(results);
  		finder.parentNode.insertBefore(wrap, finder);
  		wrap.appendChild(finder);
  		
  		//Get rid of browser suggestions
  		finder.autocomplete = "off";
  		
  		//Set results container width to match the input
  		inner.style.width = finder.offsetWidth + "px";
  		
  		//Set config for convenience of other methods
  		const findConfig = {
  			form: form,
  			finder: finder,
  			id: idInput,
  			results: results
  			
  		};
  		this._findConfig = findConfig;
  		
  		//Stop refresh keeping a previous value (which won't be valid without corresponding ID)
  		findConfig.finder.value = "";
  		
  		form.addEventListener('input', (e) => this._showEntryOptions(e));
  		form.addEventListener('submit', (e) => this._findSubmit(e));
  		results.addEventListener('click', (e) => this._selectFilteredEntry(e) );
  	}
  	
  	/**
  	 * Add entries to the "#filtered-entries", filtered by the value of the event-triggering input.
  	 * @protected
  	 * @param {object} e
  	 */
  	_showEntryOptions(e) {
  		const val = e.target.value;
  		if (val.trim() === "") {
  			this._findConfig.results.innerHTML = "";
  			return null;
  		}
  		
  		const filtered = this._filterEntries(val);
  		const results = this._findConfig.results;
  		results.innerHTML = "";
  		
  		for (const entry of filtered) {
  			const item = document.createElement("li");
  			item.dataset.id = entry.id;
  			item.innerText = entry.name;
  			results.append(item);
  		}
  	}
  	
  	/**
  	 * Filter the list of entries to match the provided search string.
  	 * @protected
  	 * @param {string} search
  	 * @return {array}
  	 */
  	_filterEntries(search) {
  		const filtered = [...document.querySelectorAll(".entry")]
  		.map(entry => {
  			return { "id": entry.id, "name": entry.innerText }
  		})
  		.filter(entry => {
  			return entry.name.toLowerCase().includes(search.toLowerCase());
  		});
  		return filtered;
  	}
  	
  	/**
  	 * Submit the clicked entry in the filtered list.
  	 * @protected
  	 * @param {object} e
  	 */
  	_selectFilteredEntry(e) {
  		if(e.target.localName !== "li") return null;
  		
  		const form = this._findConfig.form;
  		const finder = this._findConfig.finder;
  		const id = this._findConfig.id;
  		
  		finder.value = e.target.innerText;
  		id.value = e.target.dataset.id;
  		
  		form.requestSubmit();
  	}
  	
  	/**
  	 * The submit action of the find form.
  	 * Pan to the entry with submitted ID, if it exists.
  	 * @protected
  	 * @param {object} e
  	 * @fires Timeline#timelineFind
  	 */
  	_findSubmit(e) {
  		e.preventDefault();
  		
  		const find = e.target.querySelector("input[name=find-id]").value;
  		e.target.querySelector("input[name=finder]").value;
  		
  		if(document.getElementById(find)) this.panToEntry(find);

  		this._findConfig.results.innerHTML = "";
  		this._findConfig.finder.value = "";
  	}
  	
  	/** 
  	 * Initialised Panzoom on the diagram.
  	 * @protected
  	 */
  	_initPanzoom() {
  		const wrap = document.createElement("div");
  		wrap.classList.add("pz-wrap");
  		this._diagram.parentNode.insertBefore(wrap, this._diagram);
  		wrap.appendChild(this._diagram);
  		
  		this._pz = this._config.panzoom(this._diagram, {
  			contain: 'outside',
  			maxScale: 3,
  			minScale: 0.5,
  			step: 0.1,
  			
  			//This option removes the default 'stopPropagation', which blocks touch events on clickable nodes.
  			handleStartEvent: (event) => {
  				event.preventDefault();
  			}
  		});
  		this._diagram.parentElement.addEventListener('wheel', this._pz.zoomWithWheel);
  	}
  	
  	/**
  	 * Handle URL hash. Hash of format '#find-{ID}' will pan to the given entry ID, if it exists.
  	 * @protected
  	 * @param {object} e
  	 */
  	_hashHandler(e) {
  		const id = location.hash.replace('#find-', '');
  		if(document.getElementById(id) && this._pz) this.panToEntry(id);
  	}
  }

  var top = 'top';
  var bottom = 'bottom';
  var right = 'right';
  var left = 'left';
  var auto = 'auto';
  var basePlacements = [top, bottom, right, left];
  var start = 'start';
  var end = 'end';
  var clippingParents = 'clippingParents';
  var viewport = 'viewport';
  var popper = 'popper';
  var reference = 'reference';
  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []); // modifiers that need to read the DOM

  var beforeRead = 'beforeRead';
  var read = 'read';
  var afterRead = 'afterRead'; // pure-logic modifiers

  var beforeMain = 'beforeMain';
  var main = 'main';
  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

  var beforeWrite = 'beforeWrite';
  var write = 'write';
  var afterWrite = 'afterWrite';
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  function getNodeName(element) {
    return element ? (element.nodeName || '').toLowerCase() : null;
  }

  function getWindow(node) {
    if (node == null) {
      return window;
    }

    if (node.toString() !== '[object Window]') {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }

    return node;
  }

  function isElement$1(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }

  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }

  function isShadowRoot(node) {
    // IE 11 has no ShadowRoot
    if (typeof ShadowRoot === 'undefined') {
      return false;
    }

    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // and applies them to the HTMLElements such as popper and arrow

  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function (name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name]; // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      } // Flow doesn't support to extend this property, but it's the most
      // effective way to apply styles to an HTMLElement
      // $FlowFixMe[cannot-write]


      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (name) {
        var value = attributes[name];

        if (value === false) {
          element.removeAttribute(name);
        } else {
          element.setAttribute(name, value === true ? '' : value);
        }
      });
    });
  }

  function effect$2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: '0',
        top: '0',
        margin: '0'
      },
      arrow: {
        position: 'absolute'
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;

    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }

    return function () {
      Object.keys(state.elements).forEach(function (name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

        var style = styleProperties.reduce(function (style, property) {
          style[property] = '';
          return style;
        }, {}); // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }

        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  } // eslint-disable-next-line import/no-unused-modules


  var applyStyles$1 = {
    name: 'applyStyles',
    enabled: true,
    phase: 'write',
    fn: applyStyles,
    effect: effect$2,
    requires: ['computeStyles']
  };

  function getBasePlacement$1(placement) {
    return placement.split('-')[0];
  }

  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  function getUAString() {
    var uaData = navigator.userAgentData;

    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function (item) {
        return item.brand + "/" + item.version;
      }).join(' ');
    }

    return navigator.userAgent;
  }

  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }

    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }

    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;

    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }

    var _ref = isElement$1(element) ? getWindow(element) : window,
        visualViewport = _ref.visualViewport;

    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width: width,
      height: height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x,
      x: x,
      y: y
    };
  }

  // means it doesn't take into account transforms.

  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
    // Fixes https://github.com/popperjs/popper-core/issues/1223

    var width = element.offsetWidth;
    var height = element.offsetHeight;

    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }

    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }

    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: width,
      height: height
    };
  }

  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

    if (parent.contains(child)) {
      return true;
    } // then fallback to custom implementation with Shadow DOM support
    else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;

        do {
          if (next && parent.isSameNode(next)) {
            return true;
          } // $FlowFixMe[prop-missing]: need a better way to handle this...


          next = next.parentNode || next.host;
        } while (next);
      } // Give up, the result is false


    return false;
  }

  function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
  }

  function isTableElement(element) {
    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
  }

  function getDocumentElement(element) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return ((isElement$1(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
    element.document) || window.document).documentElement;
  }

  function getParentNode(element) {
    if (getNodeName(element) === 'html') {
      return element;
    }

    return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || ( // DOM Element detected
      isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element) // fallback

    );
  }

  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle(element).position === 'fixed') {
      return null;
    }

    return element.offsetParent;
  } // `.offsetParent` reports `null` for fixed elements, while absolute elements
  // return the containing block


  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());

    if (isIE && isHTMLElement(element)) {
      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
      var elementCss = getComputedStyle(element);

      if (elementCss.position === 'fixed') {
        return null;
      }
    }

    var currentNode = getParentNode(element);

    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }

    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
      // create a containing block.
      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }

    return null;
  } // Gets the closest ancestor positioned element. Handles some edge cases,
  // such as table ancestors and cross browser bugs.


  function getOffsetParent(element) {
    var window = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);

    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
      offsetParent = getTrueOffsetParent(offsetParent);
    }

    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
      return window;
    }

    return offsetParent || getContainingBlock(element) || window;
  }

  function getMainAxisFromPlacement(placement) {
    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
  }

  function within(min$1, value, max$1) {
    return max(min$1, min(value, max$1));
  }
  function withinMaxClamp(min, value, max) {
    var v = within(min, value, max);
    return v > max ? max : v;
  }

  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  function expandToHashMap(value, keys) {
    return keys.reduce(function (hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  var toPaddingObject = function toPaddingObject(padding, state) {
    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  };

  function arrow(_ref) {
    var _state$modifiersData$;

    var state = _ref.state,
        name = _ref.name,
        options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement$1(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? 'height' : 'width';

    if (!arrowElement || !popperOffsets) {
      return;
    }

    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === 'y' ? top : left;
    var maxProp = axis === 'y' ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds

    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = within(min, center, max); // Prevents breaking syntax highlighting...

    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
  }

  function effect$1(_ref2) {
    var state = _ref2.state,
        options = _ref2.options;
    var _options$element = options.element,
        arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

    if (arrowElement == null) {
      return;
    } // CSS selector


    if (typeof arrowElement === 'string') {
      arrowElement = state.elements.popper.querySelector(arrowElement);

      if (!arrowElement) {
        return;
      }
    }

    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }

    state.elements.arrow = arrowElement;
  } // eslint-disable-next-line import/no-unused-modules


  var arrow$1 = {
    name: 'arrow',
    enabled: true,
    phase: 'main',
    fn: arrow,
    effect: effect$1,
    requires: ['popperOffsets'],
    requiresIfExists: ['preventOverflow']
  };

  function getVariation(placement) {
    return placement.split('-')[1];
  }

  var unsetSides = {
    top: 'auto',
    right: 'auto',
    bottom: 'auto',
    left: 'auto'
  }; // Round the offsets to the nearest suitable subpixel based on the DPR.
  // Zooming can change the DPR, but it seems to report a value that will
  // cleanly divide the values into the appropriate subpixels.

  function roundOffsetsByDPR(_ref, win) {
    var x = _ref.x,
        y = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }

  function mapToStyles(_ref2) {
    var _Object$assign2;

    var popper = _ref2.popper,
        popperRect = _ref2.popperRect,
        placement = _ref2.placement,
        variation = _ref2.variation,
        offsets = _ref2.offsets,
        position = _ref2.position,
        gpuAcceleration = _ref2.gpuAcceleration,
        adaptive = _ref2.adaptive,
        roundOffsets = _ref2.roundOffsets,
        isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x,
        x = _offsets$x === void 0 ? 0 : _offsets$x,
        _offsets$y = offsets.y,
        y = _offsets$y === void 0 ? 0 : _offsets$y;

    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
      x: x,
      y: y
    }) : {
      x: x,
      y: y
    };

    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty('x');
    var hasY = offsets.hasOwnProperty('y');
    var sideX = left;
    var sideY = top;
    var win = window;

    if (adaptive) {
      var offsetParent = getOffsetParent(popper);
      var heightProp = 'clientHeight';
      var widthProp = 'clientWidth';

      if (offsetParent === getWindow(popper)) {
        offsetParent = getDocumentElement(popper);

        if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
          heightProp = 'scrollHeight';
          widthProp = 'scrollWidth';
        }
      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


      offsetParent = offsetParent;

      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
        offsetParent[heightProp];
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }

      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
        offsetParent[widthProp];
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }

    var commonStyles = Object.assign({
      position: position
    }, adaptive && unsetSides);

    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x: x,
      y: y
    }, getWindow(popper)) : {
      x: x,
      y: y
    };

    x = _ref4.x;
    y = _ref4.y;

    if (gpuAcceleration) {
      var _Object$assign;

      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }

    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
  }

  function computeStyles(_ref5) {
    var state = _ref5.state,
        options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration,
        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
        _options$adaptive = options.adaptive,
        adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
        _options$roundOffsets = options.roundOffsets,
        roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement$1(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration: gpuAcceleration,
      isFixed: state.options.strategy === 'fixed'
    };

    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive: adaptive,
        roundOffsets: roundOffsets
      })));
    }

    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: 'absolute',
        adaptive: false,
        roundOffsets: roundOffsets
      })));
    }

    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-placement': state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules


  var computeStyles$1 = {
    name: 'computeStyles',
    enabled: true,
    phase: 'beforeWrite',
    fn: computeStyles,
    data: {}
  };

  var passive = {
    passive: true
  };

  function effect(_ref) {
    var state = _ref.state,
        instance = _ref.instance,
        options = _ref.options;
    var _options$scroll = options.scroll,
        scroll = _options$scroll === void 0 ? true : _options$scroll,
        _options$resize = options.resize,
        resize = _options$resize === void 0 ? true : _options$resize;
    var window = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.addEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.addEventListener('resize', instance.update, passive);
    }

    return function () {
      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.removeEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.removeEventListener('resize', instance.update, passive);
      }
    };
  } // eslint-disable-next-line import/no-unused-modules


  var eventListeners = {
    name: 'eventListeners',
    enabled: true,
    phase: 'write',
    fn: function fn() {},
    effect: effect,
    data: {}
  };

  var hash$1 = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash$1[matched];
    });
  }

  var hash = {
    start: 'end',
    end: 'start'
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function (matched) {
      return hash[matched];
    });
  }

  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft: scrollLeft,
      scrollTop: scrollTop
    };
  }

  function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;

    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();

      if (layoutViewport || !layoutViewport && strategy === 'fixed') {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }

    return {
      width: width,
      height: height,
      x: x + getWindowScrollBarX(element),
      y: y
    };
  }

  // of the `<html>` and `<body>` rect bounds if horizontally scrollable

  function getDocumentRect(element) {
    var _element$ownerDocumen;

    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;

    if (getComputedStyle(body || html).direction === 'rtl') {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }

    return {
      width: width,
      height: height,
      x: x,
      y: y
    };
  }

  function isScrollParent(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = getComputedStyle(element),
        overflow = _getComputedStyle.overflow,
        overflowX = _getComputedStyle.overflowX,
        overflowY = _getComputedStyle.overflowY;

    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  function getScrollParent(node) {
    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return node.ownerDocument.body;
    }

    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }

    return getScrollParent(getParentNode(node));
  }

  /*
  given a DOM element, return the list of all scroll parents, up the list of ancesors
  until we get to the top window object. This list is what we attach scroll listeners
  to, because if any of these parent elements scroll, we'll need to re-calculate the
  reference element's position.
  */

  function listScrollParents(element, list) {
    var _element$ownerDocumen;

    if (list === void 0) {
      list = [];
    }

    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)));
  }

  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === 'fixed');
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }

  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  } // A "clipping parent" is an overflowable container with the characteristic of
  // clipping (or hiding) overflowing elements with a position different from
  // `initial`


  function getClippingParents(element) {
    var clippingParents = listScrollParents(getParentNode(element));
    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

    if (!isElement$1(clipperElement)) {
      return [];
    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


    return clippingParents.filter(function (clippingParent) {
      return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
    });
  } // Gets the maximum area that the element is visible in due to any number of
  // clipping parents


  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  function computeOffsets(_ref) {
    var reference = _ref.reference,
        element = _ref.element,
        placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement$1(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;

    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference.y - element.height
        };
        break;

      case bottom:
        offsets = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;

      case right:
        offsets = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;

      case left:
        offsets = {
          x: reference.x - element.width,
          y: commonY
        };
        break;

      default:
        offsets = {
          x: reference.x,
          y: reference.y
        };
    }

    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

    if (mainAxis != null) {
      var len = mainAxis === 'y' ? 'height' : 'width';

      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
          break;

        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
          break;
      }
    }

    return offsets;
  }

  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        _options$placement = _options.placement,
        placement = _options$placement === void 0 ? state.placement : _options$placement,
        _options$strategy = _options.strategy,
        strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
        _options$boundary = _options.boundary,
        boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
        _options$rootBoundary = _options.rootBoundary,
        rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
        _options$elementConte = _options.elementContext,
        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
        _options$altBoundary = _options.altBoundary,
        altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
        _options$padding = _options.padding,
        padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: 'absolute',
      placement: placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect

    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

    if (elementContext === popper && offsetData) {
      var offset = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function (key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
        overflowOffsets[key] += offset[axis] * multiply;
      });
    }

    return overflowOffsets;
  }

  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        placement = _options.placement,
        boundary = _options.boundary,
        rootBoundary = _options.rootBoundary,
        padding = _options.padding,
        flipVariations = _options.flipVariations,
        _options$allowedAutoP = _options.allowedAutoPlacements,
        allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
      return getVariation(placement) === variation;
    }) : basePlacements;
    var allowedPlacements = placements$1.filter(function (placement) {
      return allowedAutoPlacements.indexOf(placement) >= 0;
    });

    if (allowedPlacements.length === 0) {
      allowedPlacements = placements$1;
    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


    var overflows = allowedPlacements.reduce(function (acc, placement) {
      acc[placement] = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding
      })[getBasePlacement$1(placement)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function (a, b) {
      return overflows[a] - overflows[b];
    });
  }

  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement$1(placement) === auto) {
      return [];
    }

    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }

  function flip(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;

    if (state.modifiersData[name]._skip) {
      return;
    }

    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
        specifiedFallbackPlacements = options.fallbackPlacements,
        padding = options.padding,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        _options$flipVariatio = options.flipVariations,
        flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
        allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement$1(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
      return acc.concat(getBasePlacement$1(placement) === auto ? computeAutoPlacement(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        flipVariations: flipVariations,
        allowedAutoPlacements: allowedAutoPlacements
      }) : placement);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];

    for (var i = 0; i < placements.length; i++) {
      var placement = placements[i];

      var _basePlacement = getBasePlacement$1(placement);

      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? 'width' : 'height';
      var overflow = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        altBoundary: altBoundary,
        padding: padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }

      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];

      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }

      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }

      if (checks.every(function (check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }

      checksMap.set(placement, checks);
    }

    if (makeFallbackChecks) {
      // `2` may be desired in some cases  research later
      var numberOfChecks = flipVariations ? 3 : 1;

      var _loop = function _loop(_i) {
        var fittingPlacement = placements.find(function (placement) {
          var checks = checksMap.get(placement);

          if (checks) {
            return checks.slice(0, _i).every(function (check) {
              return check;
            });
          }
        });

        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };

      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);

        if (_ret === "break") break;
      }
    }

    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  } // eslint-disable-next-line import/no-unused-modules


  var flip$1 = {
    name: 'flip',
    enabled: true,
    phase: 'main',
    fn: flip,
    requiresIfExists: ['offset'],
    data: {
      _skip: false
    }
  };

  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }

    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }

  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function (side) {
      return overflow[side] >= 0;
    });
  }

  function hide(_ref) {
    var state = _ref.state,
        name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: 'reference'
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets: referenceClippingOffsets,
      popperEscapeOffsets: popperEscapeOffsets,
      isReferenceHidden: isReferenceHidden,
      hasPopperEscaped: hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-reference-hidden': isReferenceHidden,
      'data-popper-escaped': hasPopperEscaped
    });
  } // eslint-disable-next-line import/no-unused-modules


  var hide$1 = {
    name: 'hide',
    enabled: true,
    phase: 'main',
    requiresIfExists: ['preventOverflow'],
    fn: hide
  };

  function distanceAndSkiddingToXY(placement, rects, offset) {
    var basePlacement = getBasePlacement$1(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
      placement: placement
    })) : offset,
        skidding = _ref[0],
        distance = _ref[1];

    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }

  function offset(_ref2) {
    var state = _ref2.state,
        options = _ref2.options,
        name = _ref2.name;
    var _options$offset = options.offset,
        offset = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function (acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement],
        x = _data$state$placement.x,
        y = _data$state$placement.y;

    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules


  var offset$1 = {
    name: 'offset',
    enabled: true,
    phase: 'main',
    requires: ['popperOffsets'],
    fn: offset
  };

  function popperOffsets(_ref) {
    var state = _ref.state,
        name = _ref.name;
    // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: 'absolute',
      placement: state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules


  var popperOffsets$1 = {
    name: 'popperOffsets',
    enabled: true,
    phase: 'read',
    fn: popperOffsets,
    data: {}
  };

  function getAltAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
  }

  function preventOverflow(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;
    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        padding = options.padding,
        _options$tether = options.tether,
        tether = _options$tether === void 0 ? true : _options$tether,
        _options$tetherOffset = options.tetherOffset,
        tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      altBoundary: altBoundary
    });
    var basePlacement = getBasePlacement$1(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };

    if (!popperOffsets) {
      return;
    }

    if (checkMainAxis) {
      var _offsetModifierState$;

      var mainSide = mainAxis === 'y' ? top : left;
      var altSide = mainAxis === 'y' ? bottom : right;
      var len = mainAxis === 'y' ? 'height' : 'width';
      var offset = popperOffsets[mainAxis];
      var min$1 = offset + overflow[mainSide];
      var max$1 = offset - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
      // outside the reference bounds

      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
      // to include its full size in the calculation. If the reference is small
      // and near the edge of a boundary, the popper can overflow even if the
      // reference is not overflowing as well (e.g. virtual elements with no
      // width or height)

      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
      popperOffsets[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset;
    }

    if (checkAltAxis) {
      var _offsetModifierState$2;

      var _mainSide = mainAxis === 'x' ? top : left;

      var _altSide = mainAxis === 'x' ? bottom : right;

      var _offset = popperOffsets[altAxis];

      var _len = altAxis === 'y' ? 'height' : 'width';

      var _min = _offset + overflow[_mainSide];

      var _max = _offset - overflow[_altSide];

      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

      popperOffsets[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules


  var preventOverflow$1 = {
    name: 'preventOverflow',
    enabled: true,
    phase: 'main',
    fn: preventOverflow,
    requiresIfExists: ['offset']
  };

  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  } // Returns the composite rect of an element relative to its offsetParent.
  // Composite means it takes into account transforms as well as layout.


  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }

    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };

    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }

      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }

    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function (modifier) {
      map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively

    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function (dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);

          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }

    modifiers.forEach(function (modifier) {
      if (!visited.has(modifier.name)) {
        // check for visited object
        sort(modifier);
      }
    });
    return result;
  }

  function orderModifiers(modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase

    return modifierPhases.reduce(function (acc, phase) {
      return acc.concat(orderedModifiers.filter(function (modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  function debounce$1(fn) {
    var pending;
    return function () {
      if (!pending) {
        pending = new Promise(function (resolve) {
          Promise.resolve().then(function () {
            pending = undefined;
            resolve(fn());
          });
        });
      }

      return pending;
    };
  }

  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function (merged, current) {
      var existing = merged[current.name];
      merged[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged;
    }, {}); // IE11 does not support Object.values

    return Object.keys(merged).map(function (key) {
      return merged[key];
    });
  }

  var DEFAULT_OPTIONS = {
    placement: 'bottom',
    modifiers: [],
    strategy: 'absolute'
  };

  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return !args.some(function (element) {
      return !(element && typeof element.getBoundingClientRect === 'function');
    });
  }

  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }

    var _generatorOptions = generatorOptions,
        _generatorOptions$def = _generatorOptions.defaultModifiers,
        defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
        _generatorOptions$def2 = _generatorOptions.defaultOptions,
        defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper(reference, popper, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var state = {
        placement: 'bottom',
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference,
          popper: popper
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state: state,
        setOptions: function setOptions(setOptionsAction) {
          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options);
          state.scrollParents = {
            reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
            popper: listScrollParents(popper)
          }; // Orders the modifiers based on their dependencies and `phase`
          // properties

          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

          state.orderedModifiers = orderedModifiers.filter(function (m) {
            return m.enabled;
          });
          runModifierEffects();
          return instance.update();
        },
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }

          var _state$elements = state.elements,
              reference = _state$elements.reference,
              popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
          // anymore

          if (!areValidElements(reference, popper)) {
            return;
          } // Store the reference and popper rects to be read by modifiers


          state.rects = {
            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
            popper: getLayoutRect(popper)
          }; // Modifiers have the ability to reset the current update cycle. The
          // most common use case for this is the `flip` modifier changing the
          // placement, which then needs to re-run all the modifiers, because the
          // logic was previously ran for the previous placement and is therefore
          // stale/incorrect

          state.reset = false;
          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
          // is filled with the initial data specified by the modifier. This means
          // it doesn't persist and is fresh on each update.
          // To ensure persistent data, use `${name}#persistent`

          state.orderedModifiers.forEach(function (modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });

          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }

            var _state$orderedModifie = state.orderedModifiers[index],
                fn = _state$orderedModifie.fn,
                _state$orderedModifie2 = _state$orderedModifie.options,
                _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                name = _state$orderedModifie.name;

            if (typeof fn === 'function') {
              state = fn({
                state: state,
                options: _options,
                name: name,
                instance: instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce$1(function () {
          return new Promise(function (resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };

      if (!areValidElements(reference, popper)) {
        return instance;
      }

      instance.setOptions(options).then(function (state) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state);
        }
      }); // Modifiers have the ability to execute arbitrary code before the first
      // update cycle runs. They will be executed in the same order as the update
      // cycle. This is useful when a modifier adds some persistent data that
      // other modifiers need to use, but the modifier is run after the dependent
      // one.

      function runModifierEffects() {
        state.orderedModifiers.forEach(function (_ref) {
          var name = _ref.name,
              _ref$options = _ref.options,
              options = _ref$options === void 0 ? {} : _ref$options,
              effect = _ref.effect;

          if (typeof effect === 'function') {
            var cleanupFn = effect({
              state: state,
              name: name,
              instance: instance,
              options: options
            });

            var noopFn = function noopFn() {};

            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }

      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function (fn) {
          return fn();
        });
        effectCleanupFns = [];
      }

      return instance;
    };
  }

  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
  var createPopper = /*#__PURE__*/popperGenerator({
    defaultModifiers: defaultModifiers
  }); // eslint-disable-next-line import/no-unused-modules

  /**!
  * tippy.js v6.3.7
  * (c) 2017-2021 atomiks
  * MIT License
  */
  var BOX_CLASS = "tippy-box";
  var CONTENT_CLASS = "tippy-content";
  var BACKDROP_CLASS = "tippy-backdrop";
  var ARROW_CLASS = "tippy-arrow";
  var SVG_ARROW_CLASS = "tippy-svg-arrow";
  var TOUCH_OPTIONS = {
    passive: true,
    capture: true
  };
  var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {
    return document.body;
  };
  function getValueAtIndexOrReturn(value, index, defaultValue) {
    if (Array.isArray(value)) {
      var v = value[index];
      return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
    }

    return value;
  }
  function isType(value, type) {
    var str = {}.toString.call(value);
    return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
  }
  function invokeWithArgsOrReturn(value, args) {
    return typeof value === 'function' ? value.apply(void 0, args) : value;
  }
  function debounce(fn, ms) {
    // Avoid wrapping in `setTimeout` if ms is 0 anyway
    if (ms === 0) {
      return fn;
    }

    var timeout;
    return function (arg) {
      clearTimeout(timeout);
      timeout = setTimeout(function () {
        fn(arg);
      }, ms);
    };
  }
  function removeProperties(obj, keys) {
    var clone = Object.assign({}, obj);
    keys.forEach(function (key) {
      delete clone[key];
    });
    return clone;
  }
  function splitBySpaces(value) {
    return value.split(/\s+/).filter(Boolean);
  }
  function normalizeToArray(value) {
    return [].concat(value);
  }
  function pushIfUnique(arr, value) {
    if (arr.indexOf(value) === -1) {
      arr.push(value);
    }
  }
  function unique(arr) {
    return arr.filter(function (item, index) {
      return arr.indexOf(item) === index;
    });
  }
  function getBasePlacement(placement) {
    return placement.split('-')[0];
  }
  function arrayFrom(value) {
    return [].slice.call(value);
  }
  function removeUndefinedProps(obj) {
    return Object.keys(obj).reduce(function (acc, key) {
      if (obj[key] !== undefined) {
        acc[key] = obj[key];
      }

      return acc;
    }, {});
  }

  function div() {
    return document.createElement('div');
  }
  function isElement(value) {
    return ['Element', 'Fragment'].some(function (type) {
      return isType(value, type);
    });
  }
  function isNodeList(value) {
    return isType(value, 'NodeList');
  }
  function isMouseEvent(value) {
    return isType(value, 'MouseEvent');
  }
  function isReferenceElement(value) {
    return !!(value && value._tippy && value._tippy.reference === value);
  }
  function getArrayOfElements(value) {
    if (isElement(value)) {
      return [value];
    }

    if (isNodeList(value)) {
      return arrayFrom(value);
    }

    if (Array.isArray(value)) {
      return value;
    }

    return arrayFrom(document.querySelectorAll(value));
  }
  function setTransitionDuration(els, value) {
    els.forEach(function (el) {
      if (el) {
        el.style.transitionDuration = value + "ms";
      }
    });
  }
  function setVisibilityState(els, state) {
    els.forEach(function (el) {
      if (el) {
        el.setAttribute('data-state', state);
      }
    });
  }
  function getOwnerDocument(elementOrElements) {
    var _element$ownerDocumen;

    var _normalizeToArray = normalizeToArray(elementOrElements),
        element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body


    return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
  }
  function isCursorOutsideInteractiveBorder(popperTreeData, event) {
    var clientX = event.clientX,
        clientY = event.clientY;
    return popperTreeData.every(function (_ref) {
      var popperRect = _ref.popperRect,
          popperState = _ref.popperState,
          props = _ref.props;
      var interactiveBorder = props.interactiveBorder;
      var basePlacement = getBasePlacement(popperState.placement);
      var offsetData = popperState.modifiersData.offset;

      if (!offsetData) {
        return true;
      }

      var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
      var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
      var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
      var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
      var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
      var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
      var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
      var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
      return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
    });
  }
  function updateTransitionEndListener(box, action, listener) {
    var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
    // `webkitTransitionEnd`...

    ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
      box[method](event, listener);
    });
  }
  /**
   * Compared to xxx.contains, this function works for dom structures with shadow
   * dom
   */

  function actualContains(parent, child) {
    var target = child;

    while (target) {
      var _target$getRootNode;

      if (parent.contains(target)) {
        return true;
      }

      target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
    }

    return false;
  }

  var currentInput = {
    isTouch: false
  };
  var lastMouseMoveTime = 0;
  /**
   * When a `touchstart` event is fired, it's assumed the user is using touch
   * input. We'll bind a `mousemove` event listener to listen for mouse input in
   * the future. This way, the `isTouch` property is fully dynamic and will handle
   * hybrid devices that use a mix of touch + mouse input.
   */

  function onDocumentTouchStart() {
    if (currentInput.isTouch) {
      return;
    }

    currentInput.isTouch = true;

    if (window.performance) {
      document.addEventListener('mousemove', onDocumentMouseMove);
    }
  }
  /**
   * When two `mousemove` event are fired consecutively within 20ms, it's assumed
   * the user is using mouse input again. `mousemove` can fire on touch devices as
   * well, but very rarely that quickly.
   */

  function onDocumentMouseMove() {
    var now = performance.now();

    if (now - lastMouseMoveTime < 20) {
      currentInput.isTouch = false;
      document.removeEventListener('mousemove', onDocumentMouseMove);
    }

    lastMouseMoveTime = now;
  }
  /**
   * When an element is in focus and has a tippy, leaving the tab/window and
   * returning causes it to show again. For mouse users this is unexpected, but
   * for keyboard use it makes sense.
   * TODO: find a better technique to solve this problem
   */

  function onWindowBlur() {
    var activeElement = document.activeElement;

    if (isReferenceElement(activeElement)) {
      var instance = activeElement._tippy;

      if (activeElement.blur && !instance.state.isVisible) {
        activeElement.blur();
      }
    }
  }
  function bindGlobalEventListeners() {
    document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
    window.addEventListener('blur', onWindowBlur);
  }

  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
  var isIE11 = isBrowser ? // @ts-ignore
  !!window.msCrypto : false;

  var pluginProps = {
    animateFill: false,
    followCursor: false,
    inlinePositioning: false,
    sticky: false
  };
  var renderProps = {
    allowHTML: false,
    animation: 'fade',
    arrow: true,
    content: '',
    inertia: false,
    maxWidth: 350,
    role: 'tooltip',
    theme: '',
    zIndex: 9999
  };
  var defaultProps = Object.assign({
    appendTo: TIPPY_DEFAULT_APPEND_TO,
    aria: {
      content: 'auto',
      expanded: 'auto'
    },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: true,
    ignoreAttributes: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: '',
    offset: [0, 10],
    onAfterUpdate: function onAfterUpdate() {},
    onBeforeUpdate: function onBeforeUpdate() {},
    onCreate: function onCreate() {},
    onDestroy: function onDestroy() {},
    onHidden: function onHidden() {},
    onHide: function onHide() {},
    onMount: function onMount() {},
    onShow: function onShow() {},
    onShown: function onShown() {},
    onTrigger: function onTrigger() {},
    onUntrigger: function onUntrigger() {},
    onClickOutside: function onClickOutside() {},
    placement: 'top',
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: false,
    touch: true,
    trigger: 'mouseenter focus',
    triggerTarget: null
  }, pluginProps, renderProps);
  var defaultKeys = Object.keys(defaultProps);
  var setDefaultProps = function setDefaultProps(partialProps) {

    var keys = Object.keys(partialProps);
    keys.forEach(function (key) {
      defaultProps[key] = partialProps[key];
    });
  };
  function getExtendedPassedProps(passedProps) {
    var plugins = passedProps.plugins || [];
    var pluginProps = plugins.reduce(function (acc, plugin) {
      var name = plugin.name,
          defaultValue = plugin.defaultValue;

      if (name) {
        var _name;

        acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
      }

      return acc;
    }, {});
    return Object.assign({}, passedProps, pluginProps);
  }
  function getDataAttributeProps(reference, plugins) {
    var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
      plugins: plugins
    }))) : defaultKeys;
    var props = propKeys.reduce(function (acc, key) {
      var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

      if (!valueAsString) {
        return acc;
      }

      if (key === 'content') {
        acc[key] = valueAsString;
      } else {
        try {
          acc[key] = JSON.parse(valueAsString);
        } catch (e) {
          acc[key] = valueAsString;
        }
      }

      return acc;
    }, {});
    return props;
  }
  function evaluateProps(reference, props) {
    var out = Object.assign({}, props, {
      content: invokeWithArgsOrReturn(props.content, [reference])
    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
    out.aria = Object.assign({}, defaultProps.aria, out.aria);
    out.aria = {
      expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
      content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
    };
    return out;
  }

  var innerHTML = function innerHTML() {
    return 'innerHTML';
  };

  function dangerouslySetInnerHTML(element, html) {
    element[innerHTML()] = html;
  }

  function createArrowElement(value) {
    var arrow = div();

    if (value === true) {
      arrow.className = ARROW_CLASS;
    } else {
      arrow.className = SVG_ARROW_CLASS;

      if (isElement(value)) {
        arrow.appendChild(value);
      } else {
        dangerouslySetInnerHTML(arrow, value);
      }
    }

    return arrow;
  }

  function setContent(content, props) {
    if (isElement(props.content)) {
      dangerouslySetInnerHTML(content, '');
      content.appendChild(props.content);
    } else if (typeof props.content !== 'function') {
      if (props.allowHTML) {
        dangerouslySetInnerHTML(content, props.content);
      } else {
        content.textContent = props.content;
      }
    }
  }
  function getChildren(popper) {
    var box = popper.firstElementChild;
    var boxChildren = arrayFrom(box.children);
    return {
      box: box,
      content: boxChildren.find(function (node) {
        return node.classList.contains(CONTENT_CLASS);
      }),
      arrow: boxChildren.find(function (node) {
        return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
      }),
      backdrop: boxChildren.find(function (node) {
        return node.classList.contains(BACKDROP_CLASS);
      })
    };
  }
  function render(instance) {
    var popper = div();
    var box = div();
    box.className = BOX_CLASS;
    box.setAttribute('data-state', 'hidden');
    box.setAttribute('tabindex', '-1');
    var content = div();
    content.className = CONTENT_CLASS;
    content.setAttribute('data-state', 'hidden');
    setContent(content, instance.props);
    popper.appendChild(box);
    box.appendChild(content);
    onUpdate(instance.props, instance.props);

    function onUpdate(prevProps, nextProps) {
      var _getChildren = getChildren(popper),
          box = _getChildren.box,
          content = _getChildren.content,
          arrow = _getChildren.arrow;

      if (nextProps.theme) {
        box.setAttribute('data-theme', nextProps.theme);
      } else {
        box.removeAttribute('data-theme');
      }

      if (typeof nextProps.animation === 'string') {
        box.setAttribute('data-animation', nextProps.animation);
      } else {
        box.removeAttribute('data-animation');
      }

      if (nextProps.inertia) {
        box.setAttribute('data-inertia', '');
      } else {
        box.removeAttribute('data-inertia');
      }

      box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;

      if (nextProps.role) {
        box.setAttribute('role', nextProps.role);
      } else {
        box.removeAttribute('role');
      }

      if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
        setContent(content, instance.props);
      }

      if (nextProps.arrow) {
        if (!arrow) {
          box.appendChild(createArrowElement(nextProps.arrow));
        } else if (prevProps.arrow !== nextProps.arrow) {
          box.removeChild(arrow);
          box.appendChild(createArrowElement(nextProps.arrow));
        }
      } else if (arrow) {
        box.removeChild(arrow);
      }
    }

    return {
      popper: popper,
      onUpdate: onUpdate
    };
  } // Runtime check to identify if the render function is the default one; this
  // way we can apply default CSS transitions logic and it can be tree-shaken away

  render.$$tippy = true;

  var idCounter = 1;
  var mouseMoveListeners = []; // Used by `hideAll()`

  var mountedInstances = [];
  function createTippy(reference, passedProps) {
    var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
    //  Private members
    // ===========================================================================

    var showTimeout;
    var hideTimeout;
    var scheduleHideAnimationFrame;
    var isVisibleFromClick = false;
    var didHideDueToDocumentMouseDown = false;
    var didTouchMove = false;
    var ignoreOnFirstUpdate = false;
    var lastTriggerEvent;
    var currentTransitionEndListener;
    var onFirstUpdate;
    var listeners = [];
    var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
    var currentTarget; // ===========================================================================
    //  Public members
    // ===========================================================================

    var id = idCounter++;
    var popperInstance = null;
    var plugins = unique(props.plugins);
    var state = {
      // Is the instance currently enabled?
      isEnabled: true,
      // Is the tippy currently showing and not transitioning out?
      isVisible: false,
      // Has the instance been destroyed?
      isDestroyed: false,
      // Is the tippy currently mounted to the DOM?
      isMounted: false,
      // Has the tippy finished transitioning in?
      isShown: false
    };
    var instance = {
      // properties
      id: id,
      reference: reference,
      popper: div(),
      popperInstance: popperInstance,
      props: props,
      state: state,
      plugins: plugins,
      // methods
      clearDelayTimeouts: clearDelayTimeouts,
      setProps: setProps,
      setContent: setContent,
      show: show,
      hide: hide,
      hideWithInteractivity: hideWithInteractivity,
      enable: enable,
      disable: disable,
      unmount: unmount,
      destroy: destroy
    }; // TODO: Investigate why this early return causes a TDZ error in the tests 
    // it doesn't seem to happen in the browser

    /* istanbul ignore if */

    if (!props.render) {

      return instance;
    } // ===========================================================================
    // Initial mutations
    // ===========================================================================


    var _props$render = props.render(instance),
        popper = _props$render.popper,
        onUpdate = _props$render.onUpdate;

    popper.setAttribute('data-tippy-root', '');
    popper.id = "tippy-" + instance.id;
    instance.popper = popper;
    reference._tippy = instance;
    popper._tippy = instance;
    var pluginsHooks = plugins.map(function (plugin) {
      return plugin.fn(instance);
    });
    var hasAriaExpanded = reference.hasAttribute('aria-expanded');
    addListeners();
    handleAriaExpandedAttribute();
    handleStyles();
    invokeHook('onCreate', [instance]);

    if (props.showOnCreate) {
      scheduleShow();
    } // Prevent a tippy with a delay from hiding if the cursor left then returned
    // before it started hiding


    popper.addEventListener('mouseenter', function () {
      if (instance.props.interactive && instance.state.isVisible) {
        instance.clearDelayTimeouts();
      }
    });
    popper.addEventListener('mouseleave', function () {
      if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
        getDocument().addEventListener('mousemove', debouncedOnMouseMove);
      }
    });
    return instance; // ===========================================================================
    //  Private methods
    // ===========================================================================

    function getNormalizedTouchSettings() {
      var touch = instance.props.touch;
      return Array.isArray(touch) ? touch : [touch, 0];
    }

    function getIsCustomTouchBehavior() {
      return getNormalizedTouchSettings()[0] === 'hold';
    }

    function getIsDefaultRenderFn() {
      var _instance$props$rende;

      // @ts-ignore
      return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
    }

    function getCurrentTarget() {
      return currentTarget || reference;
    }

    function getDocument() {
      var parent = getCurrentTarget().parentNode;
      return parent ? getOwnerDocument(parent) : document;
    }

    function getDefaultTemplateChildren() {
      return getChildren(popper);
    }

    function getDelay(isShow) {
      // For touch or keyboard input, force `0` delay for UX reasons
      // Also if the instance is mounted but not visible (transitioning out),
      // ignore delay
      if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
        return 0;
      }

      return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
    }

    function handleStyles(fromHide) {
      if (fromHide === void 0) {
        fromHide = false;
      }

      popper.style.pointerEvents = instance.props.interactive && !fromHide ? '' : 'none';
      popper.style.zIndex = "" + instance.props.zIndex;
    }

    function invokeHook(hook, args, shouldInvokePropsHook) {
      if (shouldInvokePropsHook === void 0) {
        shouldInvokePropsHook = true;
      }

      pluginsHooks.forEach(function (pluginHooks) {
        if (pluginHooks[hook]) {
          pluginHooks[hook].apply(pluginHooks, args);
        }
      });

      if (shouldInvokePropsHook) {
        var _instance$props;

        (_instance$props = instance.props)[hook].apply(_instance$props, args);
      }
    }

    function handleAriaContentAttribute() {
      var aria = instance.props.aria;

      if (!aria.content) {
        return;
      }

      var attr = "aria-" + aria.content;
      var id = popper.id;
      var nodes = normalizeToArray(instance.props.triggerTarget || reference);
      nodes.forEach(function (node) {
        var currentValue = node.getAttribute(attr);

        if (instance.state.isVisible) {
          node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
        } else {
          var nextValue = currentValue && currentValue.replace(id, '').trim();

          if (nextValue) {
            node.setAttribute(attr, nextValue);
          } else {
            node.removeAttribute(attr);
          }
        }
      });
    }

    function handleAriaExpandedAttribute() {
      if (hasAriaExpanded || !instance.props.aria.expanded) {
        return;
      }

      var nodes = normalizeToArray(instance.props.triggerTarget || reference);
      nodes.forEach(function (node) {
        if (instance.props.interactive) {
          node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
        } else {
          node.removeAttribute('aria-expanded');
        }
      });
    }

    function cleanupInteractiveMouseListeners() {
      getDocument().removeEventListener('mousemove', debouncedOnMouseMove);
      mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
        return listener !== debouncedOnMouseMove;
      });
    }

    function onDocumentPress(event) {
      // Moved finger to scroll instead of an intentional tap outside
      if (currentInput.isTouch) {
        if (didTouchMove || event.type === 'mousedown') {
          return;
        }
      }

      var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper

      if (instance.props.interactive && actualContains(popper, actualTarget)) {
        return;
      } // Clicked on the event listeners target


      if (normalizeToArray(instance.props.triggerTarget || reference).some(function (el) {
        return actualContains(el, actualTarget);
      })) {
        if (currentInput.isTouch) {
          return;
        }

        if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
          return;
        }
      } else {
        invokeHook('onClickOutside', [instance, event]);
      }

      if (instance.props.hideOnClick === true) {
        instance.clearDelayTimeouts();
        instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
        // currentTarget. This lets a tippy with `focus` trigger know that it
        // should not show

        didHideDueToDocumentMouseDown = true;
        setTimeout(function () {
          didHideDueToDocumentMouseDown = false;
        }); // The listener gets added in `scheduleShow()`, but this may be hiding it
        // before it shows, and hide()'s early bail-out behavior can prevent it
        // from being cleaned up

        if (!instance.state.isMounted) {
          removeDocumentPress();
        }
      }
    }

    function onTouchMove() {
      didTouchMove = true;
    }

    function onTouchStart() {
      didTouchMove = false;
    }

    function addDocumentPress() {
      var doc = getDocument();
      doc.addEventListener('mousedown', onDocumentPress, true);
      doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
      doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
      doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
    }

    function removeDocumentPress() {
      var doc = getDocument();
      doc.removeEventListener('mousedown', onDocumentPress, true);
      doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
      doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
      doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
    }

    function onTransitionedOut(duration, callback) {
      onTransitionEnd(duration, function () {
        if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
          callback();
        }
      });
    }

    function onTransitionedIn(duration, callback) {
      onTransitionEnd(duration, callback);
    }

    function onTransitionEnd(duration, callback) {
      var box = getDefaultTemplateChildren().box;

      function listener(event) {
        if (event.target === box) {
          updateTransitionEndListener(box, 'remove', listener);
          callback();
        }
      } // Make callback synchronous if duration is 0
      // `transitionend` won't fire otherwise


      if (duration === 0) {
        return callback();
      }

      updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
      updateTransitionEndListener(box, 'add', listener);
      currentTransitionEndListener = listener;
    }

    function on(eventType, handler, options) {
      if (options === void 0) {
        options = false;
      }

      var nodes = normalizeToArray(instance.props.triggerTarget || reference);
      nodes.forEach(function (node) {
        node.addEventListener(eventType, handler, options);
        listeners.push({
          node: node,
          eventType: eventType,
          handler: handler,
          options: options
        });
      });
    }

    function addListeners() {
      if (getIsCustomTouchBehavior()) {
        on('touchstart', onTrigger, {
          passive: true
        });
        on('touchend', onMouseLeave, {
          passive: true
        });
      }

      splitBySpaces(instance.props.trigger).forEach(function (eventType) {
        if (eventType === 'manual') {
          return;
        }

        on(eventType, onTrigger);

        switch (eventType) {
          case 'mouseenter':
            on('mouseleave', onMouseLeave);
            break;

          case 'focus':
            on(isIE11 ? 'focusout' : 'blur', onBlurOrFocusOut);
            break;

          case 'focusin':
            on('focusout', onBlurOrFocusOut);
            break;
        }
      });
    }

    function removeListeners() {
      listeners.forEach(function (_ref) {
        var node = _ref.node,
            eventType = _ref.eventType,
            handler = _ref.handler,
            options = _ref.options;
        node.removeEventListener(eventType, handler, options);
      });
      listeners = [];
    }

    function onTrigger(event) {
      var _lastTriggerEvent;

      var shouldScheduleClickHide = false;

      if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
        return;
      }

      var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
      lastTriggerEvent = event;
      currentTarget = event.currentTarget;
      handleAriaExpandedAttribute();

      if (!instance.state.isVisible && isMouseEvent(event)) {
        // If scrolling, `mouseenter` events can be fired if the cursor lands
        // over a new target, but `mousemove` events don't get fired. This
        // causes interactive tooltips to get stuck open until the cursor is
        // moved
        mouseMoveListeners.forEach(function (listener) {
          return listener(event);
        });
      } // Toggle show/hide when clicking click-triggered tooltips


      if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
        shouldScheduleClickHide = true;
      } else {
        scheduleShow(event);
      }

      if (event.type === 'click') {
        isVisibleFromClick = !shouldScheduleClickHide;
      }

      if (shouldScheduleClickHide && !wasFocused) {
        scheduleHide(event);
      }
    }

    function onMouseMove(event) {
      var target = event.target;
      var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);

      if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
        return;
      }

      var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
        var _instance$popperInsta;

        var instance = popper._tippy;
        var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

        if (state) {
          return {
            popperRect: popper.getBoundingClientRect(),
            popperState: state,
            props: props
          };
        }

        return null;
      }).filter(Boolean);

      if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
        cleanupInteractiveMouseListeners();
        scheduleHide(event);
      }
    }

    function onMouseLeave(event) {
      var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

      if (shouldBail) {
        return;
      }

      if (instance.props.interactive) {
        instance.hideWithInteractivity(event);
        return;
      }

      scheduleHide(event);
    }

    function onBlurOrFocusOut(event) {
      if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
        return;
      } // If focus was moved to within the popper


      if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
        return;
      }

      scheduleHide(event);
    }

    function isEventListenerStopped(event) {
      return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
    }

    function createPopperInstance() {
      destroyPopperInstance();
      var _instance$props2 = instance.props,
          popperOptions = _instance$props2.popperOptions,
          placement = _instance$props2.placement,
          offset = _instance$props2.offset,
          getReferenceClientRect = _instance$props2.getReferenceClientRect,
          moveTransition = _instance$props2.moveTransition;
      var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
      var computedReference = getReferenceClientRect ? {
        getBoundingClientRect: getReferenceClientRect,
        contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
      } : reference;
      var tippyModifier = {
        name: '$$tippy',
        enabled: true,
        phase: 'beforeWrite',
        requires: ['computeStyles'],
        fn: function fn(_ref2) {
          var state = _ref2.state;

          if (getIsDefaultRenderFn()) {
            var _getDefaultTemplateCh = getDefaultTemplateChildren(),
                box = _getDefaultTemplateCh.box;

            ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
              if (attr === 'placement') {
                box.setAttribute('data-placement', state.placement);
              } else {
                if (state.attributes.popper["data-popper-" + attr]) {
                  box.setAttribute("data-" + attr, '');
                } else {
                  box.removeAttribute("data-" + attr);
                }
              }
            });
            state.attributes.popper = {};
          }
        }
      };
      var modifiers = [{
        name: 'offset',
        options: {
          offset: offset
        }
      }, {
        name: 'preventOverflow',
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      }, {
        name: 'flip',
        options: {
          padding: 5
        }
      }, {
        name: 'computeStyles',
        options: {
          adaptive: !moveTransition
        }
      }, tippyModifier];

      if (getIsDefaultRenderFn() && arrow) {
        modifiers.push({
          name: 'arrow',
          options: {
            element: arrow,
            padding: 3
          }
        });
      }

      modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
      instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {
        placement: placement,
        onFirstUpdate: onFirstUpdate,
        modifiers: modifiers
      }));
    }

    function destroyPopperInstance() {
      if (instance.popperInstance) {
        instance.popperInstance.destroy();
        instance.popperInstance = null;
      }
    }

    function mount() {
      var appendTo = instance.props.appendTo;
      var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
      // it's directly after the reference element so the elements inside the
      // tippy can be tabbed to
      // If there are clipping issues, the user can specify a different appendTo
      // and ensure focus management is handled correctly manually

      var node = getCurrentTarget();

      if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === 'parent') {
        parentNode = node.parentNode;
      } else {
        parentNode = invokeWithArgsOrReturn(appendTo, [node]);
      } // The popper element needs to exist on the DOM before its position can be
      // updated as Popper needs to read its dimensions


      if (!parentNode.contains(popper)) {
        parentNode.appendChild(popper);
      }

      instance.state.isMounted = true;
      createPopperInstance();
    }

    function getNestedPopperTree() {
      return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
    }

    function scheduleShow(event) {
      instance.clearDelayTimeouts();

      if (event) {
        invokeHook('onTrigger', [instance, event]);
      }

      addDocumentPress();
      var delay = getDelay(true);

      var _getNormalizedTouchSe = getNormalizedTouchSettings(),
          touchValue = _getNormalizedTouchSe[0],
          touchDelay = _getNormalizedTouchSe[1];

      if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
        delay = touchDelay;
      }

      if (delay) {
        showTimeout = setTimeout(function () {
          instance.show();
        }, delay);
      } else {
        instance.show();
      }
    }

    function scheduleHide(event) {
      instance.clearDelayTimeouts();
      invokeHook('onUntrigger', [instance, event]);

      if (!instance.state.isVisible) {
        removeDocumentPress();
        return;
      } // For interactive tippies, scheduleHide is added to a document.body handler
      // from onMouseLeave so must intercept scheduled hides from mousemove/leave
      // events when trigger contains mouseenter and click, and the tip is
      // currently shown as a result of a click.


      if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
        return;
      }

      var delay = getDelay(false);

      if (delay) {
        hideTimeout = setTimeout(function () {
          if (instance.state.isVisible) {
            instance.hide();
          }
        }, delay);
      } else {
        // Fixes a `transitionend` problem when it fires 1 frame too
        // late sometimes, we don't want hide() to be called.
        scheduleHideAnimationFrame = requestAnimationFrame(function () {
          instance.hide();
        });
      }
    } // ===========================================================================
    //  Public methods
    // ===========================================================================


    function enable() {
      instance.state.isEnabled = true;
    }

    function disable() {
      // Disabling the instance should also hide it
      // https://github.com/atomiks/tippy.js-react/issues/106
      instance.hide();
      instance.state.isEnabled = false;
    }

    function clearDelayTimeouts() {
      clearTimeout(showTimeout);
      clearTimeout(hideTimeout);
      cancelAnimationFrame(scheduleHideAnimationFrame);
    }

    function setProps(partialProps) {

      if (instance.state.isDestroyed) {
        return;
      }

      invokeHook('onBeforeUpdate', [instance, partialProps]);
      removeListeners();
      var prevProps = instance.props;
      var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
        ignoreAttributes: true
      }));
      instance.props = nextProps;
      addListeners();

      if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
        cleanupInteractiveMouseListeners();
        debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
      } // Ensure stale aria-expanded attributes are removed


      if (prevProps.triggerTarget && !nextProps.triggerTarget) {
        normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
          node.removeAttribute('aria-expanded');
        });
      } else if (nextProps.triggerTarget) {
        reference.removeAttribute('aria-expanded');
      }

      handleAriaExpandedAttribute();
      handleStyles();

      if (onUpdate) {
        onUpdate(prevProps, nextProps);
      }

      if (instance.popperInstance) {
        createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
        // and the nested ones get re-rendered first.
        // https://github.com/atomiks/tippyjs-react/issues/177
        // TODO: find a cleaner / more efficient solution(!)

        getNestedPopperTree().forEach(function (nestedPopper) {
          // React (and other UI libs likely) requires a rAF wrapper as it flushes
          // its work in one
          requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
        });
      }

      invokeHook('onAfterUpdate', [instance, partialProps]);
    }

    function setContent(content) {
      instance.setProps({
        content: content
      });
    }

    function show() {


      var isAlreadyVisible = instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

      if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
        return;
      } // Normalize `disabled` behavior across browsers.
      // Firefox allows events on disabled elements, but Chrome doesn't.
      // Using a wrapper element (i.e. <span>) is recommended.


      if (getCurrentTarget().hasAttribute('disabled')) {
        return;
      }

      invokeHook('onShow', [instance], false);

      if (instance.props.onShow(instance) === false) {
        return;
      }

      instance.state.isVisible = true;

      if (getIsDefaultRenderFn()) {
        popper.style.visibility = 'visible';
      }

      handleStyles();
      addDocumentPress();

      if (!instance.state.isMounted) {
        popper.style.transition = 'none';
      } // If flipping to the opposite side after hiding at least once, the
      // animation will use the wrong placement without resetting the duration


      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
            box = _getDefaultTemplateCh2.box,
            content = _getDefaultTemplateCh2.content;

        setTransitionDuration([box, content], 0);
      }

      onFirstUpdate = function onFirstUpdate() {
        var _instance$popperInsta2;

        if (!instance.state.isVisible || ignoreOnFirstUpdate) {
          return;
        }

        ignoreOnFirstUpdate = true; // reflow

        void popper.offsetHeight;
        popper.style.transition = instance.props.moveTransition;

        if (getIsDefaultRenderFn() && instance.props.animation) {
          var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
              _box = _getDefaultTemplateCh3.box,
              _content = _getDefaultTemplateCh3.content;

          setTransitionDuration([_box, _content], duration);
          setVisibilityState([_box, _content], 'visible');
        }

        handleAriaContentAttribute();
        handleAriaExpandedAttribute();
        pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the
        // popper has been positioned for the first time

        (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
        invokeHook('onMount', [instance]);

        if (instance.props.animation && getIsDefaultRenderFn()) {
          onTransitionedIn(duration, function () {
            instance.state.isShown = true;
            invokeHook('onShown', [instance]);
          });
        }
      };

      mount();
    }

    function hide() {


      var isAlreadyHidden = !instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

      if (isAlreadyHidden || isDestroyed || isDisabled) {
        return;
      }

      invokeHook('onHide', [instance], false);

      if (instance.props.onHide(instance) === false) {
        return;
      }

      instance.state.isVisible = false;
      instance.state.isShown = false;
      ignoreOnFirstUpdate = false;
      isVisibleFromClick = false;

      if (getIsDefaultRenderFn()) {
        popper.style.visibility = 'hidden';
      }

      cleanupInteractiveMouseListeners();
      removeDocumentPress();
      handleStyles(true);

      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
            box = _getDefaultTemplateCh4.box,
            content = _getDefaultTemplateCh4.content;

        if (instance.props.animation) {
          setTransitionDuration([box, content], duration);
          setVisibilityState([box, content], 'hidden');
        }
      }

      handleAriaContentAttribute();
      handleAriaExpandedAttribute();

      if (instance.props.animation) {
        if (getIsDefaultRenderFn()) {
          onTransitionedOut(duration, instance.unmount);
        }
      } else {
        instance.unmount();
      }
    }

    function hideWithInteractivity(event) {

      getDocument().addEventListener('mousemove', debouncedOnMouseMove);
      pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }

    function unmount() {

      if (instance.state.isVisible) {
        instance.hide();
      }

      if (!instance.state.isMounted) {
        return;
      }

      destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
      // tree by default. This seems mainly for interactive tippies, but we should
      // find a workaround if possible

      getNestedPopperTree().forEach(function (nestedPopper) {
        nestedPopper._tippy.unmount();
      });

      if (popper.parentNode) {
        popper.parentNode.removeChild(popper);
      }

      mountedInstances = mountedInstances.filter(function (i) {
        return i !== instance;
      });
      instance.state.isMounted = false;
      invokeHook('onHidden', [instance]);
    }

    function destroy() {

      if (instance.state.isDestroyed) {
        return;
      }

      instance.clearDelayTimeouts();
      instance.unmount();
      removeListeners();
      delete reference._tippy;
      instance.state.isDestroyed = true;
      invokeHook('onDestroy', [instance]);
    }
  }

  function tippy(targets, optionalProps) {
    if (optionalProps === void 0) {
      optionalProps = {};
    }

    var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);

    bindGlobalEventListeners();
    var passedProps = Object.assign({}, optionalProps, {
      plugins: plugins
    });
    var elements = getArrayOfElements(targets);

    var instances = elements.reduce(function (acc, reference) {
      var instance = reference && createTippy(reference, passedProps);

      if (instance) {
        acc.push(instance);
      }

      return acc;
    }, []);
    return isElement(targets) ? instances[0] : instances;
  }

  tippy.defaultProps = defaultProps;
  tippy.setDefaultProps = setDefaultProps;
  tippy.currentInput = currentInput;

  // every time the popper is destroyed (i.e. a new target), removing the styles
  // and causing transitions to break for singletons when the console is open, but
  // most notably for non-transform styles being used, `gpuAcceleration: false`.

  Object.assign({}, applyStyles$1, {
    effect: function effect(_ref) {
      var state = _ref.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;

      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      } // intentionally return no cleanup function
      // return () => { ... }

    }
  });

  var BUBBLING_EVENTS_MAP = {
    mouseover: 'mouseenter',
    focusin: 'focus',
    click: 'click'
  };
  /**
   * Creates a delegate instance that controls the creation of tippy instances
   * for child elements (`target` CSS selector).
   */

  function delegate(targets, props) {

    var listeners = [];
    var childTippyInstances = [];
    var disabled = false;
    var target = props.target;
    var nativeProps = removeProperties(props, ['target']);
    var parentProps = Object.assign({}, nativeProps, {
      trigger: 'manual',
      touch: false
    });
    var childProps = Object.assign({
      touch: defaultProps.touch
    }, nativeProps, {
      showOnCreate: true
    });
    var returnValue = tippy(targets, parentProps);
    var normalizedReturnValue = normalizeToArray(returnValue);

    function onTrigger(event) {
      if (!event.target || disabled) {
        return;
      }

      var targetNode = event.target.closest(target);

      if (!targetNode) {
        return;
      } // Get relevant trigger with fallbacks:
      // 1. Check `data-tippy-trigger` attribute on target node
      // 2. Fallback to `trigger` passed to `delegate()`
      // 3. Fallback to `defaultProps.trigger`


      var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || defaultProps.trigger; // @ts-ignore

      if (targetNode._tippy) {
        return;
      }

      if (event.type === 'touchstart' && typeof childProps.touch === 'boolean') {
        return;
      }

      if (event.type !== 'touchstart' && trigger.indexOf(BUBBLING_EVENTS_MAP[event.type]) < 0) {
        return;
      }

      var instance = tippy(targetNode, childProps);

      if (instance) {
        childTippyInstances = childTippyInstances.concat(instance);
      }
    }

    function on(node, eventType, handler, options) {
      if (options === void 0) {
        options = false;
      }

      node.addEventListener(eventType, handler, options);
      listeners.push({
        node: node,
        eventType: eventType,
        handler: handler,
        options: options
      });
    }

    function addEventListeners(instance) {
      var reference = instance.reference;
      on(reference, 'touchstart', onTrigger, TOUCH_OPTIONS);
      on(reference, 'mouseover', onTrigger);
      on(reference, 'focusin', onTrigger);
      on(reference, 'click', onTrigger);
    }

    function removeEventListeners() {
      listeners.forEach(function (_ref) {
        var node = _ref.node,
            eventType = _ref.eventType,
            handler = _ref.handler,
            options = _ref.options;
        node.removeEventListener(eventType, handler, options);
      });
      listeners = [];
    }

    function applyMutations(instance) {
      var originalDestroy = instance.destroy;
      var originalEnable = instance.enable;
      var originalDisable = instance.disable;

      instance.destroy = function (shouldDestroyChildInstances) {
        if (shouldDestroyChildInstances === void 0) {
          shouldDestroyChildInstances = true;
        }

        if (shouldDestroyChildInstances) {
          childTippyInstances.forEach(function (instance) {
            instance.destroy();
          });
        }

        childTippyInstances = [];
        removeEventListeners();
        originalDestroy();
      };

      instance.enable = function () {
        originalEnable();
        childTippyInstances.forEach(function (instance) {
          return instance.enable();
        });
        disabled = false;
      };

      instance.disable = function () {
        originalDisable();
        childTippyInstances.forEach(function (instance) {
          return instance.disable();
        });
        disabled = true;
      };

      addEventListeners(instance);
    }

    normalizedReturnValue.forEach(applyMutations);
    return returnValue;
  }

  tippy.setDefaultProps({
    render: render
  });

  /**
   * Add a Tippy popover with a Wikipedia summary for entries with a `data-wikipedia` attribute.
   * @param {string} elements
   */
  class WikipediaPopover {
  	
  	constructor(selector) {
  		const wrapInstance = this;
  		
  		const elements = document.getElementById("diagram").querySelectorAll(selector);
  		for (const element of elements) {
  			element.classList.add("entry-popover");
  		}
  		
  		delegate(
  			"#diagram",
  			{
  				target: selector,
  				theme: "tl",
  				content: 'Loading...',
  				allowHTML: true,
  				interactive: true,
  				trigger: 'click',
  				onShow(instance) {
  				wrapInstance.getPopoverContents(instance.reference)
  				.then(content => instance.setContent(content))
  				.catch((e) => {
  					console.log(`Error loading info for ${instance.reference.id}: ${e}`);
  				});
  			}
  		});
  	}
  	
  	async getPopoverContents(el) {
  		console.log("Contents requested");
  		const link = el.dataset.wikipedia;
  		const title = link.substring(link.lastIndexOf("/")+1);
  		const url =  `https://en.wikipedia.org/w/api.php?format=json&action=query&explaintext&prop=extracts|info|pageprops&exsentences=3&titles=${title}&origin=*`;
  		return fetch(url)
  			.then(response => response.json())
  			.then(
  				(data) => {
  					const page = data["query"]["pages"][Object.keys(data.query.pages)[0]];
  					return `<h3>${page.title}</h3>
							<p>${page.extract}</p>
							<p><a href="${link}" class="read-more">Read more on Wikipedia</a></p>`;
  				})
  	}
  }

  function processCsv(csv) {
  	const data = a(csv);
  	for (const entry of data) {
  		for(const p in entry) {
  			if(entry[p] == "") {
  				delete entry[p];
  			}
  		}
  	}
  	return data;
  }

  Promise.all([
  	fetch("parties.csv"),
  	fetch("events.csv")
  ])
  .then( (responses) => { 
  	return Promise.all(responses.map( (response) => { return response.text() }) )
  })
  .then( (results) => {
  	console.log(results);
  	const parties = processCsv(results[0]);
  	const events = processCsv(results[1]);

  	const tl = new Timeline(
  		"diagram",
  		{
  			yearStart: 1915,
  			panzoom: Panzoom
  		},
  		parties,
  		events
  	);
  	tl.create();
  });

  new WikipediaPopover("[data-wikipedia]");

}));
